from __future__ import annotations

import datetime

import wrapt

from coredis import PureToken
from coredis.client import AbstractRedis, AbstractRedisCluster, ResponseParser
from coredis.pool import ClusterConnectionPool, ConnectionPool
from coredis.typing import (
    Any,
    AnyStr,
    Dict,
    Generic,
    Iterable,
    KeyT,
    Literal,
    Optional,
    Set,
    StringT,
    Tuple,
    Union,
    ValueT,
)

class PipelineImpl(AbstractRedis[AnyStr]):
    scripts: Set
    def __init__(self, connection_pool, response_callbacks, transaction): ...
    async def watch(self, *keys: Union[str, bytes]) -> bool: ...
    async def unwatch(self) -> bool: ...
    async def execute(self, raise_on_error=True) -> Tuple[Any, ...]: ...
    async def execute_command(self, *args, **kwargs) -> Any: ...
    def multi(self): ...
    async def __aenter__(self) -> "PipelineImpl": ...
    async def __aexit__(self, exc_type, exc_val, exc_tb): ...

class ClusterPipelineImpl(AbstractRedisCluster[AnyStr], ResponseParser):
    def __init__(
        self,
        connection_pool: "ClusterConnectionPool",
        result_callbacks=None,
        response_callbacks=None,
        startup_nodes=None,
        transaction: "Optional[bool]" = False,
        watches=None,
    ): ...
    async def watch(self, *keys: "KeyT") -> bool: ...
    async def unwatch(*args, **kwargs): ...
    async def execute(self, raise_on_error=True) -> Tuple[Any, ...]: ...
    async def execute_command(self, *args, **kwargs): ...
    def multi(*args, **kwargs): ...
    async def __aenter__(self) -> "ClusterPipelineImpl": ...
    async def __aexit__(self, exc_type, exc_val, exc_tb): ...

class Pipeline(wrapt.ObjectProxy, Generic[AnyStr]):
    scripts: Set
    async def copy(
        self,
        source: "KeyT",
        destination: "KeyT",
        db: "Optional[int]" = None,
        replace: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def delete(self, keys: "Iterable[KeyT]") -> Pipeline: ...
    async def dump(self, key: "KeyT") -> Pipeline: ...
    async def exists(self, keys: "Iterable[KeyT]") -> Pipeline: ...
    async def expire(
        self,
        key: "KeyT",
        seconds: "Union[int, datetime.timedelta]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT]]" = None,
    ) -> Pipeline: ...
    async def expireat(
        self,
        key: "KeyT",
        unix_time_seconds: "Union[int, datetime.datetime]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT]]" = None,
    ) -> Pipeline: ...
    async def expiretime(self, key: "Union[str, bytes]") -> Pipeline: ...
    async def keys(self, pattern: "StringT" = "*") -> Pipeline: ...
    async def migrate(
        self,
        host: "StringT",
        port: "int",
        destination_db: "int",
        timeout: "int",
        *keys: "KeyT",
        copy: "Optional[bool]" = None,
        replace: "Optional[bool]" = None,
        auth: "Optional[StringT]" = None,
        username: "Optional[StringT]" = None,
        password: "Optional[StringT]" = None,
    ) -> Pipeline: ...
    async def move(self, key: "KeyT", db: "int") -> Pipeline: ...
    async def object_encoding(self, key: "KeyT") -> Pipeline: ...
    async def object_freq(self, key: "KeyT") -> Pipeline: ...
    async def object_idletime(self, key: "KeyT") -> Pipeline: ...
    async def object_refcount(self, key: "KeyT") -> Pipeline: ...
    async def persist(self, key: "KeyT") -> Pipeline: ...
    async def pexpire(
        self,
        key: "KeyT",
        milliseconds: "Union[int, datetime.timedelta]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT]]" = None,
    ) -> Pipeline: ...
    async def pexpireat(
        self,
        key: "KeyT",
        unix_time_milliseconds: "Union[int, datetime.datetime]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT]]" = None,
    ) -> Pipeline: ...
    async def pexpiretime(self, key: "Union[str, bytes]") -> Pipeline: ...
    async def pttl(self, key: "KeyT") -> Pipeline: ...
    async def randomkey(self) -> Pipeline: ...
    async def rename(self, key: "KeyT", newkey: "KeyT") -> Pipeline: ...
    async def renamenx(self, key: "KeyT", newkey: "KeyT") -> Pipeline: ...
    async def restore(
        self,
        key: "KeyT",
        ttl: "int",
        serialized_value: "bytes",
        replace: "Optional[bool]" = None,
        absttl: "Optional[bool]" = None,
        idletime: "Optional[Union[int, datetime.timedelta]]" = None,
        freq: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def scan(
        self,
        cursor: "Optional[int]" = 0,
        match: "Optional[StringT]" = None,
        count: "Optional[int]" = None,
        type_: "Optional[StringT]" = None,
    ) -> Pipeline: ...
    async def sort(
        self,
        key: "KeyT",
        gets: "Optional[Iterable[KeyT]]" = None,
        by: "Optional[StringT]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        alpha: "Optional[bool]" = None,
        store: "Optional[KeyT]" = None,
    ) -> Pipeline: ...
    async def sort_ro(
        self,
        key: "KeyT",
        gets: "Optional[Iterable[KeyT]]" = None,
        by: "Optional[StringT]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        alpha: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def touch(self, keys: "Iterable[KeyT]") -> Pipeline: ...
    async def ttl(self, key: "KeyT") -> Pipeline: ...
    async def type(self, key: "KeyT") -> Pipeline: ...
    async def unlink(self, keys: "Iterable[KeyT]") -> Pipeline: ...
    async def wait(self, numreplicas: "int", timeout: "int") -> Pipeline: ...
    async def append(self, key: "KeyT", value: "ValueT") -> Pipeline: ...
    async def decr(self, key: "KeyT") -> Pipeline: ...
    async def decrby(self, key: "KeyT", decrement: "int") -> Pipeline: ...
    async def get(self, key: "KeyT") -> Pipeline: ...
    async def getdel(self, key: "KeyT") -> Pipeline: ...
    async def getex(
        self,
        key: "KeyT",
        ex: "Optional[Union[int, datetime.timedelta]]" = None,
        px: "Optional[Union[int, datetime.timedelta]]" = None,
        exat: "Optional[Union[int, datetime.datetime]]" = None,
        pxat: "Optional[Union[int, datetime.datetime]]" = None,
        persist: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def getrange(self, key: "KeyT", start: "int", end: "int") -> Pipeline: ...
    async def getset(self, key: "KeyT", value: "ValueT") -> Pipeline: ...
    async def incr(self, key: "KeyT") -> Pipeline: ...
    async def incrby(self, key: "KeyT", increment: "int") -> Pipeline: ...
    async def incrbyfloat(
        self, key: "KeyT", increment: "Union[int, float]"
    ) -> Pipeline: ...
    async def lcs(
        self,
        key1: "KeyT",
        key2: "KeyT",
        len_: "Optional[bool]" = None,
        idx: "Optional[bool]" = None,
        minmatchlen: "Optional[int]" = None,
        withmatchlen: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def mget(self, keys: "Iterable[KeyT]") -> Pipeline: ...
    async def mset(self, key_values: "Dict[KeyT, ValueT]") -> Pipeline: ...
    async def msetnx(self, key_values: "Dict[KeyT, ValueT]") -> Pipeline: ...
    async def psetex(
        self,
        key: "KeyT",
        milliseconds: "Union[int, datetime.timedelta]",
        value: "ValueT",
    ) -> Pipeline: ...
    async def set(
        self,
        key: "KeyT",
        value: "ValueT",
        ex: "Optional[Union[int, datetime.timedelta]]" = None,
        px: "Optional[Union[int, datetime.timedelta]]" = None,
        exat: "Optional[Union[int, datetime.datetime]]" = None,
        pxat: "Optional[Union[int, datetime.datetime]]" = None,
        keepttl: "Optional[bool]" = None,
        condition: "Optional[Literal[PureToken.NX, PureToken.XX]]" = None,
        get: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def setex(
        self, key: "KeyT", value: "ValueT", seconds: "Union[int, datetime.timedelta]"
    ) -> Pipeline: ...
    async def setnx(self, key: "KeyT", value: "ValueT") -> Pipeline: ...
    async def setrange(
        self, key: "KeyT", offset: "int", value: "ValueT"
    ) -> Pipeline: ...
    async def strlen(self, key: "KeyT") -> Pipeline: ...
    async def substr(self, key: "KeyT", start: "int", end: "int") -> Pipeline: ...
    async def bitcount(
        self,
        key: "KeyT",
        start: "Optional[int]" = None,
        end: "Optional[int]" = None,
        index_unit: "Optional[Literal[PureToken.BIT, PureToken.BYTE]]" = None,
    ) -> Pipeline: ...
    async def bitop(
        self, keys: "Iterable[KeyT]", operation: "StringT", destkey: "KeyT"
    ) -> Pipeline: ...
    async def bitpos(
        self,
        key: "KeyT",
        bit: "int",
        start: "Optional[int]" = None,
        end: "Optional[int]" = None,
        end_index_unit: "Optional[Literal[PureToken.BYTE, PureToken.BIT]]" = None,
    ) -> Pipeline: ...
    async def getbit(self, key: "KeyT", offset: "int") -> Pipeline: ...
    async def setbit(self, key: "KeyT", offset: "int", value: "int") -> Pipeline: ...
    async def hdel(self, key: "KeyT", fields: "Iterable[StringT]") -> Pipeline: ...
    async def hexists(self, key: "KeyT", field: "StringT") -> Pipeline: ...
    async def hget(self, key: "KeyT", field: "StringT") -> Pipeline: ...
    async def hgetall(self, key: "KeyT") -> Pipeline: ...
    async def hincrby(
        self, key: "KeyT", field: "StringT", increment: "int"
    ) -> Pipeline: ...
    async def hincrbyfloat(
        self, key: "KeyT", field: "StringT", increment: "Union[int, float]"
    ) -> Pipeline: ...
    async def hkeys(self, key: "KeyT") -> Pipeline: ...
    async def hlen(self, key: "KeyT") -> Pipeline: ...
    async def hmget(self, key: "KeyT", fields: "Iterable[StringT]") -> Pipeline: ...
    async def hmset(
        self, key: "KeyT", field_values: "Dict[StringT, ValueT]"
    ) -> Pipeline: ...
    async def hrandfield(
        self,
        key: "KeyT",
        count: "Optional[int]" = None,
        withvalues: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def hscan(
        self,
        key: "KeyT",
        cursor: "Optional[int]" = 0,
        match: "Optional[StringT]" = None,
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def hset(
        self, key: "KeyT", field_values: "Dict[StringT, ValueT]"
    ) -> Pipeline: ...
    async def hsetnx(
        self, key: "KeyT", field: "StringT", value: "ValueT"
    ) -> Pipeline: ...
    async def hstrlen(self, key: "KeyT", field: "StringT") -> Pipeline: ...
    async def hvals(self, key: "KeyT") -> Pipeline: ...
    async def blmove(
        self,
        source: "KeyT",
        destination: "KeyT",
        wherefrom: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        whereto: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        timeout: "Union[int, float]",
    ) -> Pipeline: ...
    async def blmpop(
        self,
        keys: "Iterable[KeyT]",
        timeout: "Union[int, float]",
        where: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def blpop(
        self, keys: "Iterable[KeyT]", timeout: "Union[int, float]"
    ) -> Pipeline: ...
    async def brpop(
        self, keys: "Iterable[KeyT]", timeout: "Union[int, float]"
    ) -> Pipeline: ...
    async def brpoplpush(
        self, source: "KeyT", destination: "KeyT", timeout: "Union[int, float]"
    ) -> Pipeline: ...
    async def lindex(self, key: "KeyT", index: "int") -> Pipeline: ...
    async def linsert(
        self,
        key: "KeyT",
        where: "Literal[PureToken.BEFORE, PureToken.AFTER]",
        pivot: "ValueT",
        element: "ValueT",
    ) -> Pipeline: ...
    async def llen(self, key: "KeyT") -> Pipeline: ...
    async def lmove(
        self,
        source: "KeyT",
        destination: "KeyT",
        wherefrom: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        whereto: "Literal[PureToken.LEFT, PureToken.RIGHT]",
    ) -> Pipeline: ...
    async def lmpop(
        self,
        keys: "Iterable[Union[str, bytes]]",
        where: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def lpop(self, key: "KeyT", count: "Optional[int]" = None) -> Pipeline: ...
    async def lpos(
        self,
        key: "KeyT",
        element: "ValueT",
        rank: "Optional[int]" = None,
        count: "Optional[int]" = None,
        maxlen: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def lpush(self, key: "KeyT", elements: "Iterable[ValueT]") -> Pipeline: ...
    async def lpushx(self, key: "KeyT", elements: "Iterable[ValueT]") -> Pipeline: ...
    async def lrange(self, key: "KeyT", start: "int", stop: "int") -> Pipeline: ...
    async def lrem(self, key: "KeyT", count: "int", element: "ValueT") -> Pipeline: ...
    async def lset(self, key: "KeyT", index: "int", element: "ValueT") -> Pipeline: ...
    async def ltrim(self, key: "KeyT", start: "int", stop: "int") -> Pipeline: ...
    async def rpop(self, key: "KeyT", count: "Optional[int]" = None) -> Pipeline: ...
    async def rpoplpush(self, source: "KeyT", destination: "KeyT") -> Pipeline: ...
    async def rpush(self, key: "KeyT", elements: "Iterable[ValueT]") -> Pipeline: ...
    async def rpushx(self, key: "KeyT", elements: "Iterable[ValueT]") -> Pipeline: ...
    async def sadd(self, key: "KeyT", members: "Iterable[ValueT]") -> Pipeline: ...
    async def scard(self, key: "KeyT") -> Pipeline: ...
    async def sdiff(self, keys: "Iterable[KeyT]") -> Pipeline: ...
    async def sdiffstore(
        self, keys: "Iterable[KeyT]", destination: "KeyT"
    ) -> Pipeline: ...
    async def sinter(self, keys: "Iterable[KeyT]") -> Pipeline: ...
    async def sintercard(
        self, keys: "Iterable[Union[str, bytes]]", limit: "Optional[int]" = None
    ) -> Pipeline: ...
    async def sinterstore(
        self, keys: "Iterable[KeyT]", destination: "KeyT"
    ) -> Pipeline: ...
    async def sismember(self, key: "KeyT", member: "ValueT") -> Pipeline: ...
    async def smembers(self, key: "KeyT") -> Pipeline: ...
    async def smismember(
        self, key: "KeyT", members: "Iterable[ValueT]"
    ) -> Pipeline: ...
    async def smove(
        self, source: "KeyT", destination: "KeyT", member: "ValueT"
    ) -> Pipeline: ...
    async def spop(self, key: "KeyT", count: "Optional[int]" = None) -> Pipeline: ...
    async def srandmember(
        self, key: "KeyT", count: "Optional[int]" = None
    ) -> Pipeline: ...
    async def srem(self, key: "KeyT", members: "Iterable[ValueT]") -> Pipeline: ...
    async def sscan(
        self,
        key: "KeyT",
        cursor: "Optional[int]" = 0,
        match: "Optional[StringT]" = None,
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def sunion(self, keys: "Iterable[KeyT]") -> Pipeline: ...
    async def sunionstore(
        self, keys: "Iterable[KeyT]", destination: "KeyT"
    ) -> Pipeline: ...
    async def bzmpop(
        self,
        keys: "Iterable[KeyT]",
        timeout: "Union[int, float]",
        where: "Literal[PureToken.MIN, PureToken.MAX]",
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def bzpopmax(
        self, keys: "Iterable[KeyT]", timeout: "Union[int, float]"
    ) -> Pipeline: ...
    async def bzpopmin(
        self, keys: "Iterable[KeyT]", timeout: "Union[int, float]"
    ) -> Pipeline: ...
    async def zadd(
        self,
        key: "KeyT",
        member_scores: "Dict[StringT, float]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX]]" = None,
        comparison: "Optional[Literal[PureToken.GT, PureToken.LT]]" = None,
        change: "Optional[bool]" = None,
        increment: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def zcard(self, key: "KeyT") -> Pipeline: ...
    async def zcount(self, key: "KeyT", min_: "ValueT", max_: "ValueT") -> Pipeline: ...
    async def zdiff(
        self, keys: "Iterable[KeyT]", withscores: "Optional[bool]" = None
    ) -> Pipeline: ...
    async def zdiffstore(
        self, keys: "Iterable[KeyT]", destination: "KeyT"
    ) -> Pipeline: ...
    async def zincrby(
        self, key: "KeyT", member: "ValueT", increment: "int"
    ) -> Pipeline: ...
    async def zinter(
        self,
        keys: "Iterable[KeyT]",
        weights: "Optional[Iterable[int]]" = None,
        aggregate: "Optional[Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX]]" = None,
        withscores: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def zintercard(
        self, keys: "Iterable[KeyT]", limit: "Optional[int]" = None
    ) -> Pipeline: ...
    async def zinterstore(
        self,
        keys: "Iterable[KeyT]",
        destination: "KeyT",
        weights: "Optional[Iterable[int]]" = None,
        aggregate: "Optional[Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX]]" = None,
    ) -> Pipeline: ...
    async def zlexcount(
        self, key: "KeyT", min_: "ValueT", max_: "ValueT"
    ) -> Pipeline: ...
    async def zmpop(
        self,
        keys: "Iterable[KeyT]",
        where: "Literal[PureToken.MIN, PureToken.MAX]",
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def zmscore(self, key: "KeyT", members: "Iterable[ValueT]") -> Pipeline: ...
    async def zpopmax(self, key: "KeyT", count: "Optional[int]" = None) -> Pipeline: ...
    async def zpopmin(self, key: "KeyT", count: "Optional[int]" = None) -> Pipeline: ...
    async def zrandmember(
        self,
        key: "KeyT",
        count: "Optional[int]" = None,
        withscores: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def zrange(
        self,
        key: "KeyT",
        min_: "Union[int, ValueT]",
        max_: "Union[int, ValueT]",
        sortby: "Optional[Literal[PureToken.BYSCORE, PureToken.BYLEX]]" = None,
        rev: "Optional[bool]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
        withscores: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def zrangebylex(
        self,
        key: "KeyT",
        min_: "ValueT",
        max_: "ValueT",
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def zrangebyscore(
        self,
        key: "KeyT",
        min_: "Union[int, float]",
        max_: "Union[int, float]",
        withscores: "Optional[bool]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def zrangestore(
        self,
        dst: "KeyT",
        src: "KeyT",
        min_: "Union[int, ValueT]",
        max_: "Union[int, ValueT]",
        sortby: "Optional[Literal[PureToken.BYSCORE, PureToken.BYLEX]]" = None,
        rev: "Optional[bool]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def zrank(self, key: "KeyT", member: "ValueT") -> Pipeline: ...
    async def zrem(self, key: "KeyT", members: "Iterable[ValueT]") -> Pipeline: ...
    async def zremrangebylex(
        self, key: "KeyT", min_: "ValueT", max_: "ValueT"
    ) -> Pipeline: ...
    async def zremrangebyrank(
        self, key: "KeyT", start: "int", stop: "int"
    ) -> Pipeline: ...
    async def zremrangebyscore(
        self, key: "KeyT", min_: "Union[int, float]", max_: "Union[int, float]"
    ) -> Pipeline: ...
    async def zrevrange(
        self,
        key: "KeyT",
        start: "int",
        stop: "int",
        withscores: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def zrevrangebylex(
        self,
        key: "KeyT",
        max_: "ValueT",
        min_: "ValueT",
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def zrevrangebyscore(
        self,
        key: "KeyT",
        max_: "Union[int, float]",
        min_: "Union[int, float]",
        withscores: "Optional[bool]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def zrevrank(self, key: "KeyT", member: "ValueT") -> Pipeline: ...
    async def zscan(
        self,
        key: "KeyT",
        cursor: "Optional[int]" = 0,
        match: "Optional[StringT]" = None,
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def zscore(self, key: "KeyT", member: "ValueT") -> Pipeline: ...
    async def zunion(
        self,
        keys: "Iterable[KeyT]",
        weights: "Optional[Iterable[int]]" = None,
        aggregate: "Optional[Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX]]" = None,
        withscores: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def zunionstore(
        self,
        keys: "Iterable[KeyT]",
        destination: "KeyT",
        weights: "Optional[Iterable[int]]" = None,
        aggregate: "Optional[Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX]]" = None,
    ) -> Pipeline: ...
    async def pfadd(self, key: "KeyT", *elements: "ValueT") -> Pipeline: ...
    async def pfcount(self, keys: "Iterable[KeyT]") -> Pipeline: ...
    async def pfmerge(
        self, destkey: "KeyT", sourcekeys: "Iterable[KeyT]"
    ) -> Pipeline: ...
    async def geoadd(
        self,
        key: "KeyT",
        longitude_latitude_members: "Iterable[Tuple[Union[int, float], Union[int, float], ValueT]]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX]]" = None,
        change: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def geodist(
        self,
        key: "KeyT",
        member1: "StringT",
        member2: "StringT",
        unit: "Optional[Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]]" = None,
    ) -> Pipeline: ...
    async def geohash(self, key: "KeyT", members: "Iterable[ValueT]") -> Pipeline: ...
    async def geopos(self, key: "KeyT", members: "Iterable[ValueT]") -> Pipeline: ...
    async def georadius(
        self,
        key: "KeyT",
        longitude: "Union[int, float]",
        latitude: "Union[int, float]",
        radius: "Union[int, float]",
        unit: "Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]",
        withcoord: "Optional[bool]" = None,
        withdist: "Optional[bool]" = None,
        withhash: "Optional[bool]" = None,
        count: "Optional[int]" = None,
        any_: "Optional[bool]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        store: "Optional[KeyT]" = None,
        storedist: "Optional[KeyT]" = None,
    ) -> Pipeline: ...
    async def georadiusbymember(
        self,
        key: "KeyT",
        member: "ValueT",
        radius: "Union[int, float]",
        unit: "Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]",
        withcoord: "Optional[bool]" = None,
        withdist: "Optional[bool]" = None,
        withhash: "Optional[bool]" = None,
        count: "Optional[int]" = None,
        any_: "Optional[bool]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        store: "Optional[KeyT]" = None,
        storedist: "Optional[KeyT]" = None,
    ) -> Pipeline: ...
    async def geosearch(
        self,
        key: "KeyT",
        member: "Optional[ValueT]" = None,
        longitude: "Optional[Union[int, float]]" = None,
        latitude: "Optional[Union[int, float]]" = None,
        radius: "Optional[Union[int, float]]" = None,
        circle_unit: "Optional[Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]]" = None,
        width: "Optional[Union[int, float]]" = None,
        height: "Optional[Union[int, float]]" = None,
        box_unit: "Optional[Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        count: "Optional[int]" = None,
        any_: "Optional[bool]" = None,
        withcoord: "Optional[bool]" = None,
        withdist: "Optional[bool]" = None,
        withhash: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def geosearchstore(
        self,
        destination: "KeyT",
        source: "KeyT",
        member: "Optional[ValueT]" = None,
        longitude: "Optional[Union[int, float]]" = None,
        latitude: "Optional[Union[int, float]]" = None,
        radius: "Optional[Union[int, float]]" = None,
        circle_unit: "Optional[Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]]" = None,
        width: "Optional[Union[int, float]]" = None,
        height: "Optional[Union[int, float]]" = None,
        box_unit: "Optional[Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        count: "Optional[int]" = None,
        any_: "Optional[bool]" = None,
        storedist: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def xack(
        self, key: "KeyT", group: "StringT", identifiers: "Iterable[ValueT]"
    ) -> Pipeline: ...
    async def xadd(
        self,
        key: "KeyT",
        field_values: "Dict[StringT, ValueT]",
        identifier: "Optional[ValueT]" = None,
        nomkstream: "Optional[bool]" = None,
        trim_strategy: "Optional[Literal[PureToken.MAXLEN, PureToken.MINID]]" = None,
        threshold: "Optional[int]" = None,
        trim_operator: "Optional[Literal[PureToken.EQUAL, PureToken.APPROXIMATELY]]" = None,
        limit: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def xautoclaim(
        self,
        key: "KeyT",
        group: "StringT",
        consumer: "StringT",
        min_idle_time: "Union[int, datetime.timedelta]",
        start: "ValueT",
        count: "Optional[int]" = None,
        justid: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def xclaim(
        self,
        key: "KeyT",
        group: "StringT",
        consumer: "StringT",
        min_idle_time: "Union[int, datetime.timedelta]",
        identifiers: "Iterable[ValueT]",
        idle: "Optional[int]" = None,
        time: "Optional[Union[int, datetime.datetime]]" = None,
        retrycount: "Optional[int]" = None,
        force: "Optional[bool]" = None,
        justid: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def xdel(self, key: "KeyT", identifiers: "Iterable[ValueT]") -> Pipeline: ...
    async def xgroup_create(
        self,
        key: "KeyT",
        groupname: "StringT",
        identifier: "Optional[ValueT]" = None,
        mkstream: "Optional[bool]" = None,
        entriesread: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def xgroup_createconsumer(
        self, key: "KeyT", groupname: "StringT", consumername: "StringT"
    ) -> Pipeline: ...
    async def xgroup_delconsumer(
        self, key: "KeyT", groupname: "StringT", consumername: "StringT"
    ) -> Pipeline: ...
    async def xgroup_destroy(self, key: "KeyT", groupname: "StringT") -> Pipeline: ...
    async def xgroup_setid(
        self,
        key: "KeyT",
        groupname: "StringT",
        identifier: "Optional[ValueT]" = None,
        entriesread: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def xinfo_consumers(self, key: "KeyT", groupname: "StringT") -> Pipeline: ...
    async def xinfo_groups(self, key: "KeyT") -> Pipeline: ...
    async def xinfo_stream(
        self, key: "KeyT", full: "Optional[bool]" = None, count: "Optional[int]" = None
    ) -> Pipeline: ...
    async def xlen(self, key: "KeyT") -> Pipeline: ...
    async def xpending(
        self,
        key: "KeyT",
        group: "StringT",
        start: "Optional[ValueT]" = None,
        end: "Optional[ValueT]" = None,
        count: "Optional[int]" = None,
        idle: "Optional[int]" = None,
        consumer: "Optional[StringT]" = None,
    ) -> Pipeline: ...
    async def xrange(
        self,
        key: "KeyT",
        start: "Optional[ValueT]" = None,
        end: "Optional[ValueT]" = None,
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def xread(
        self,
        streams: "Dict[ValueT, ValueT]",
        count: "Optional[int]" = None,
        block: "Optional[Union[int, datetime.timedelta]]" = None,
    ) -> Pipeline: ...
    async def xreadgroup(
        self,
        group: "StringT",
        consumer: "StringT",
        streams: "Dict[ValueT, ValueT]",
        count: "Optional[int]" = None,
        block: "Optional[Union[int, datetime.timedelta]]" = None,
        noack: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def xrevrange(
        self,
        key: "KeyT",
        end: "Optional[ValueT]" = None,
        start: "Optional[ValueT]" = None,
        count: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def xtrim(
        self,
        key: "KeyT",
        trim_strategy: "Literal[PureToken.MAXLEN, PureToken.MINID]",
        threshold: "int",
        trim_operator: "Optional[Literal[PureToken.EQUAL, PureToken.APPROXIMATELY]]" = None,
        limit: "Optional[int]" = None,
    ) -> Pipeline: ...
    async def eval(
        self,
        script: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> Pipeline: ...
    async def evalsha(
        self,
        sha1: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> Pipeline: ...
    async def evalsha_ro(
        self,
        sha1: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> Pipeline: ...
    async def eval_ro(
        self,
        script: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> Pipeline: ...
    async def fcall(
        self,
        function: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> Pipeline: ...
    async def fcall_ro(
        self,
        function: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> Pipeline: ...
    async def function_delete(self, library_name: "StringT") -> Pipeline: ...
    async def function_dump(self) -> Pipeline: ...
    async def function_flush(
        self, async_: "Optional[Literal[PureToken.SYNC, PureToken.ASYNC]]" = None
    ) -> Pipeline: ...
    async def function_kill(self) -> Pipeline: ...
    async def function_list(
        self, libraryname: "Optional[StringT]" = None, withcode: "Optional[bool]" = None
    ) -> Pipeline: ...
    async def function_load(
        self, function_code: "StringT", replace: "Optional[bool]" = None
    ) -> Pipeline: ...
    async def function_restore(
        self,
        serialized_value: "bytes",
        policy: "Optional[Literal[PureToken.FLUSH, PureToken.APPEND, PureToken.REPLACE]]" = None,
    ) -> Pipeline: ...
    async def function_stats(self) -> Pipeline: ...
    async def script_debug(
        self, mode: "Literal[PureToken.YES, PureToken.SYNC, PureToken.NO]"
    ) -> Pipeline: ...
    async def script_exists(self, sha1s: "Iterable[StringT]") -> Pipeline: ...
    async def script_flush(
        self, sync_type: "Optional[Literal[PureToken.SYNC, PureToken.ASYNC]]" = None
    ) -> Pipeline: ...
    async def script_kill(self) -> Pipeline: ...
    async def script_load(self, script: "StringT") -> Pipeline: ...
    async def publish(self, channel: "StringT", message: "StringT") -> Pipeline: ...
    async def pubsub_channels(
        self, pattern: "Optional[StringT]" = None
    ) -> Pipeline: ...
    async def pubsub_numpat(self) -> Pipeline: ...
    async def pubsub_numsub(self, *channels: "StringT") -> Pipeline: ...
    async def acl_cat(self, categoryname: "Optional[StringT]" = None) -> Pipeline: ...
    async def acl_deluser(self, usernames: "Iterable[StringT]") -> Pipeline: ...
    async def acl_dryrun(
        self, username: "StringT", command: "StringT", *args: "ValueT"
    ) -> Pipeline: ...
    async def acl_genpass(self, bits: "Optional[int]" = None) -> Pipeline: ...
    async def acl_getuser(self, username: "StringT") -> Pipeline: ...
    async def acl_list(self) -> Pipeline: ...
    async def acl_load(self) -> Pipeline: ...
    async def acl_log(
        self, count: "Optional[int]" = None, reset: "Optional[bool]" = None
    ) -> Pipeline: ...
    async def acl_save(self) -> Pipeline: ...
    async def acl_setuser(self, username: "StringT", *rules: "StringT") -> Pipeline: ...
    async def acl_users(self) -> Pipeline: ...
    async def acl_whoami(self) -> Pipeline: ...
    async def bgrewriteaof(self) -> Pipeline: ...
    async def bgsave(self, schedule: "Optional[bool]" = None) -> Pipeline: ...
    async def command(self) -> Pipeline: ...
    async def command_count(self) -> Pipeline: ...
    async def command_docs(self, *command_names: "StringT") -> Pipeline: ...
    async def command_getkeys(
        self, command: "StringT", arguments: "Iterable[ValueT]"
    ) -> Pipeline: ...
    async def command_getkeysandflags(
        self, command: "StringT", arguments: "Iterable[ValueT]"
    ) -> Pipeline: ...
    async def command_info(self, *command_names: "StringT") -> Pipeline: ...
    async def command_list(
        self,
        module: "Optional[StringT]" = None,
        aclcat: "Optional[StringT]" = None,
        pattern: "Optional[StringT]" = None,
    ) -> Pipeline: ...
    async def config_get(self, parameters: "Iterable[StringT]") -> Pipeline: ...
    async def config_resetstat(self) -> Pipeline: ...
    async def config_rewrite(self) -> Pipeline: ...
    async def config_set(
        self, parameter_values: "Dict[StringT, ValueT]"
    ) -> Pipeline: ...
    async def dbsize(self) -> Pipeline: ...
    async def failover(
        self,
        host: "Optional[StringT]" = None,
        port: "Optional[int]" = None,
        force: "Optional[bool]" = None,
        abort: "Optional[bool]" = None,
        timeout: "Optional[Union[int, datetime.timedelta]]" = None,
    ) -> Pipeline: ...
    async def flushall(
        self, async_: "Optional[Literal[PureToken.ASYNC, PureToken.SYNC]]" = None
    ) -> Pipeline: ...
    async def flushdb(
        self, async_: "Optional[Literal[PureToken.ASYNC, PureToken.SYNC]]" = None
    ) -> Pipeline: ...
    async def info(self, *sections: "StringT") -> Pipeline: ...
    async def lastsave(self) -> Pipeline: ...
    async def latency_doctor(self) -> Pipeline: ...
    async def latency_graph(self, event: "StringT") -> Pipeline: ...
    async def latency_histogram(self, *commands: "Union[str, bytes]") -> Pipeline: ...
    async def latency_history(self, event: "StringT") -> Pipeline: ...
    async def latency_latest(self) -> Pipeline: ...
    async def latency_reset(self, *events: "StringT") -> Pipeline: ...
    async def lolwut(self, version: "Optional[int]" = None) -> Pipeline: ...
    async def memory_doctor(self) -> Pipeline: ...
    async def memory_malloc_stats(self) -> Pipeline: ...
    async def memory_purge(self) -> Pipeline: ...
    async def memory_stats(self) -> Pipeline: ...
    async def memory_usage(
        self, key: "KeyT", samples: "Optional[int]" = None
    ) -> Pipeline: ...
    async def module_list(self) -> Pipeline: ...
    async def module_load(
        self, path: "Union[str, bytes]", *args: "Union[str, bytes, int, float]"
    ) -> Pipeline: ...
    async def module_loadex(
        self,
        path: "Union[str, bytes]",
        configs: "Optional[Dict[StringT, ValueT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> Pipeline: ...
    async def module_unload(self, name: "Union[str, bytes]") -> Pipeline: ...
    async def replicaof(
        self, host: "Optional[StringT]" = None, port: "Optional[int]" = None
    ) -> Pipeline: ...
    async def role(self) -> Pipeline: ...
    async def save(self) -> Pipeline: ...
    async def shutdown(
        self,
        nosave_save: "Optional[Literal[PureToken.NOSAVE, PureToken.SAVE]]" = None,
        now: "Optional[bool]" = None,
        force: "Optional[bool]" = None,
        abort: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def slaveof(
        self, host: "Optional[StringT]" = None, port: "Optional[int]" = None
    ) -> Pipeline: ...
    async def slowlog_get(self, count: "Optional[int]" = None) -> Pipeline: ...
    async def slowlog_len(self) -> Pipeline: ...
    async def slowlog_reset(self) -> Pipeline: ...
    async def swapdb(self, index1: "int", index2: "int") -> Pipeline: ...
    async def time(self) -> Pipeline: ...
    async def auth(
        self, password: "StringT", username: "Optional[StringT]" = None
    ) -> Pipeline: ...
    async def client_caching(
        self, mode: "Literal[PureToken.YES, PureToken.NO]"
    ) -> Pipeline: ...
    async def client_getname(self) -> Pipeline: ...
    async def client_getredir(self) -> Pipeline: ...
    async def client_id(self) -> Pipeline: ...
    async def client_info(self) -> Pipeline: ...
    async def client_kill(
        self,
        ip_port: "Optional[StringT]" = None,
        identifier: "Optional[int]" = None,
        type_: "Optional[Literal[PureToken.NORMAL, PureToken.MASTER, PureToken.SLAVE, PureToken.REPLICA, PureToken.PUBSUB]]" = None,
        user: "Optional[StringT]" = None,
        addr: "Optional[StringT]" = None,
        laddr: "Optional[StringT]" = None,
        skipme: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def client_list(
        self,
        type_: "Optional[Literal[PureToken.NORMAL, PureToken.MASTER, PureToken.REPLICA, PureToken.PUBSUB]]" = None,
        identifiers: "Optional[Iterable[int]]" = None,
    ) -> Pipeline: ...
    async def client_no_evict(
        self, enabled: "Literal[PureToken.ON, PureToken.OFF]"
    ) -> Pipeline: ...
    async def client_pause(
        self,
        timeout: "int",
        mode: "Optional[Literal[PureToken.WRITE, PureToken.ALL]]" = None,
    ) -> Pipeline: ...
    async def client_reply(
        self, mode: "Literal[PureToken.ON, PureToken.OFF, PureToken.SKIP]"
    ) -> Pipeline: ...
    async def client_setname(self, connection_name: "StringT") -> Pipeline: ...
    async def client_tracking(
        self,
        status: "Literal[PureToken.ON, PureToken.OFF]",
        *prefixes: "StringT",
        redirect: "Optional[int]" = None,
        bcast: "Optional[bool]" = None,
        optin: "Optional[bool]" = None,
        optout: "Optional[bool]" = None,
        noloop: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def client_trackinginfo(self) -> Pipeline: ...
    async def client_unblock(
        self,
        client_id: "int",
        timeout_error: "Optional[Literal[PureToken.TIMEOUT, PureToken.ERROR]]" = None,
    ) -> Pipeline: ...
    async def client_unpause(self) -> Pipeline: ...
    async def echo(self, message: "StringT") -> Pipeline: ...
    async def hello(
        self,
        protover: "Optional[int]" = None,
        username: "Optional[StringT]" = None,
        password: "Optional[StringT]" = None,
        setname: "Optional[StringT]" = None,
    ) -> Pipeline: ...
    async def ping(self, message: "Optional[StringT]" = None) -> Pipeline: ...
    async def quit(self) -> Pipeline: ...
    async def reset(self) -> Pipeline: ...
    async def select(self, index: "int") -> Pipeline: ...
    async def asking(self) -> Pipeline: ...
    async def cluster_addslots(self, slots: "Iterable[int]") -> Pipeline: ...
    async def cluster_addslotsrange(
        self, slots: "Iterable[Tuple[int, int]]"
    ) -> Pipeline: ...
    async def cluster_bumpepoch(self) -> Pipeline: ...
    async def cluster_count_failure_reports(self, node_id: "StringT") -> Pipeline: ...
    async def cluster_countkeysinslot(self, slot: "int") -> Pipeline: ...
    async def cluster_delslots(self, slots: "Iterable[int]") -> Pipeline: ...
    async def cluster_delslotsrange(
        self, slots: "Iterable[Tuple[int, int]]"
    ) -> Pipeline: ...
    async def cluster_failover(
        self, options: "Optional[Literal[PureToken.FORCE, PureToken.TAKEOVER]]" = None
    ) -> Pipeline: ...
    async def cluster_flushslots(self) -> Pipeline: ...
    async def cluster_forget(self, node_id: "StringT") -> Pipeline: ...
    async def cluster_getkeysinslot(self, slot: "int", count: "int") -> Pipeline: ...
    async def cluster_info(self) -> Pipeline: ...
    async def cluster_keyslot(self, key: "KeyT") -> Pipeline: ...
    async def cluster_links(self) -> Pipeline: ...
    async def cluster_meet(self, ip: "StringT", port: "int") -> Pipeline: ...
    async def cluster_myid(self) -> Pipeline: ...
    async def cluster_nodes(self) -> Pipeline: ...
    async def cluster_replicas(self, node_id: "StringT") -> Pipeline: ...
    async def cluster_replicate(self, node_id: "StringT") -> Pipeline: ...
    async def cluster_reset(
        self, hard_soft: "Optional[Literal[PureToken.HARD, PureToken.SOFT]]" = None
    ) -> Pipeline: ...
    async def cluster_saveconfig(self) -> Pipeline: ...
    async def cluster_set_config_epoch(self, config_epoch: "int") -> Pipeline: ...
    async def cluster_setslot(
        self,
        slot: "int",
        importing: "Optional[StringT]" = None,
        migrating: "Optional[StringT]" = None,
        node: "Optional[StringT]" = None,
        stable: "Optional[bool]" = None,
    ) -> Pipeline: ...
    async def cluster_shards(self) -> Pipeline: ...
    async def cluster_slaves(self, node_id: "StringT") -> Pipeline: ...
    async def cluster_slots(self) -> Pipeline: ...
    async def readonly(self) -> Pipeline: ...
    async def readwrite(self) -> Pipeline: ...
    async def watch(self, *keys: "KeyT") -> bool: ...
    async def unwatch(self) -> bool: ...
    def multi(self): ...
    async def execute(self, raise_on_error=True) -> Tuple[Any, ...]: ...
    async def __aenter__(self) -> "Pipeline[AnyStr]": ...
    async def __aexit__(self, exc_type, exc_val, exc_tb): ...

class ClusterPipeline(wrapt.ObjectProxy, Generic[AnyStr]):
    async def copy(
        self,
        source: "KeyT",
        destination: "KeyT",
        db: "Optional[int]" = None,
        replace: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def delete(self, keys: "Iterable[KeyT]") -> ClusterPipeline: ...
    async def dump(self, key: "KeyT") -> ClusterPipeline: ...
    async def exists(self, keys: "Iterable[KeyT]") -> ClusterPipeline: ...
    async def expire(
        self,
        key: "KeyT",
        seconds: "Union[int, datetime.timedelta]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT]]" = None,
    ) -> ClusterPipeline: ...
    async def expireat(
        self,
        key: "KeyT",
        unix_time_seconds: "Union[int, datetime.datetime]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT]]" = None,
    ) -> ClusterPipeline: ...
    async def expiretime(self, key: "Union[str, bytes]") -> ClusterPipeline: ...
    async def keys(self, pattern: "StringT" = "*") -> ClusterPipeline: ...
    async def migrate(
        self,
        host: "StringT",
        port: "int",
        destination_db: "int",
        timeout: "int",
        *keys: "KeyT",
        copy: "Optional[bool]" = None,
        replace: "Optional[bool]" = None,
        auth: "Optional[StringT]" = None,
        username: "Optional[StringT]" = None,
        password: "Optional[StringT]" = None,
    ) -> ClusterPipeline: ...
    async def move(self, key: "KeyT", db: "int") -> ClusterPipeline: ...
    async def object_encoding(self, key: "KeyT") -> ClusterPipeline: ...
    async def object_freq(self, key: "KeyT") -> ClusterPipeline: ...
    async def object_idletime(self, key: "KeyT") -> ClusterPipeline: ...
    async def object_refcount(self, key: "KeyT") -> ClusterPipeline: ...
    async def persist(self, key: "KeyT") -> ClusterPipeline: ...
    async def pexpire(
        self,
        key: "KeyT",
        milliseconds: "Union[int, datetime.timedelta]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT]]" = None,
    ) -> ClusterPipeline: ...
    async def pexpireat(
        self,
        key: "KeyT",
        unix_time_milliseconds: "Union[int, datetime.datetime]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX, PureToken.GT, PureToken.LT]]" = None,
    ) -> ClusterPipeline: ...
    async def pexpiretime(self, key: "Union[str, bytes]") -> ClusterPipeline: ...
    async def pttl(self, key: "KeyT") -> ClusterPipeline: ...
    async def randomkey(self) -> ClusterPipeline: ...
    async def rename(self, key: "KeyT", newkey: "KeyT") -> ClusterPipeline: ...
    async def renamenx(self, key: "KeyT", newkey: "KeyT") -> ClusterPipeline: ...
    async def restore(
        self,
        key: "KeyT",
        ttl: "int",
        serialized_value: "bytes",
        replace: "Optional[bool]" = None,
        absttl: "Optional[bool]" = None,
        idletime: "Optional[Union[int, datetime.timedelta]]" = None,
        freq: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def scan(
        self,
        cursor: "Optional[int]" = 0,
        match: "Optional[StringT]" = None,
        count: "Optional[int]" = None,
        type_: "Optional[StringT]" = None,
    ) -> ClusterPipeline: ...
    async def sort(
        self,
        key: "KeyT",
        gets: "Optional[Iterable[KeyT]]" = None,
        by: "Optional[StringT]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        alpha: "Optional[bool]" = None,
        store: "Optional[KeyT]" = None,
    ) -> ClusterPipeline: ...
    async def sort_ro(
        self,
        key: "KeyT",
        gets: "Optional[Iterable[KeyT]]" = None,
        by: "Optional[StringT]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        alpha: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def touch(self, keys: "Iterable[KeyT]") -> ClusterPipeline: ...
    async def ttl(self, key: "KeyT") -> ClusterPipeline: ...
    async def type(self, key: "KeyT") -> ClusterPipeline: ...
    async def unlink(self, keys: "Iterable[KeyT]") -> ClusterPipeline: ...
    async def wait(self, numreplicas: "int", timeout: "int") -> ClusterPipeline: ...
    async def append(self, key: "KeyT", value: "ValueT") -> ClusterPipeline: ...
    async def decr(self, key: "KeyT") -> ClusterPipeline: ...
    async def decrby(self, key: "KeyT", decrement: "int") -> ClusterPipeline: ...
    async def get(self, key: "KeyT") -> ClusterPipeline: ...
    async def getdel(self, key: "KeyT") -> ClusterPipeline: ...
    async def getex(
        self,
        key: "KeyT",
        ex: "Optional[Union[int, datetime.timedelta]]" = None,
        px: "Optional[Union[int, datetime.timedelta]]" = None,
        exat: "Optional[Union[int, datetime.datetime]]" = None,
        pxat: "Optional[Union[int, datetime.datetime]]" = None,
        persist: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def getrange(
        self, key: "KeyT", start: "int", end: "int"
    ) -> ClusterPipeline: ...
    async def getset(self, key: "KeyT", value: "ValueT") -> ClusterPipeline: ...
    async def incr(self, key: "KeyT") -> ClusterPipeline: ...
    async def incrby(self, key: "KeyT", increment: "int") -> ClusterPipeline: ...
    async def incrbyfloat(
        self, key: "KeyT", increment: "Union[int, float]"
    ) -> ClusterPipeline: ...
    async def lcs(
        self,
        key1: "KeyT",
        key2: "KeyT",
        len_: "Optional[bool]" = None,
        idx: "Optional[bool]" = None,
        minmatchlen: "Optional[int]" = None,
        withmatchlen: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def mget(self, keys: "Iterable[KeyT]") -> ClusterPipeline: ...
    async def mset(self, key_values: "Dict[KeyT, ValueT]") -> ClusterPipeline: ...
    async def msetnx(self, key_values: "Dict[KeyT, ValueT]") -> ClusterPipeline: ...
    async def psetex(
        self,
        key: "KeyT",
        milliseconds: "Union[int, datetime.timedelta]",
        value: "ValueT",
    ) -> ClusterPipeline: ...
    async def set(
        self,
        key: "KeyT",
        value: "ValueT",
        ex: "Optional[Union[int, datetime.timedelta]]" = None,
        px: "Optional[Union[int, datetime.timedelta]]" = None,
        exat: "Optional[Union[int, datetime.datetime]]" = None,
        pxat: "Optional[Union[int, datetime.datetime]]" = None,
        keepttl: "Optional[bool]" = None,
        condition: "Optional[Literal[PureToken.NX, PureToken.XX]]" = None,
        get: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def setex(
        self, key: "KeyT", value: "ValueT", seconds: "Union[int, datetime.timedelta]"
    ) -> ClusterPipeline: ...
    async def setnx(self, key: "KeyT", value: "ValueT") -> ClusterPipeline: ...
    async def setrange(
        self, key: "KeyT", offset: "int", value: "ValueT"
    ) -> ClusterPipeline: ...
    async def strlen(self, key: "KeyT") -> ClusterPipeline: ...
    async def substr(
        self, key: "KeyT", start: "int", end: "int"
    ) -> ClusterPipeline: ...
    async def bitcount(
        self,
        key: "KeyT",
        start: "Optional[int]" = None,
        end: "Optional[int]" = None,
        index_unit: "Optional[Literal[PureToken.BIT, PureToken.BYTE]]" = None,
    ) -> ClusterPipeline: ...
    async def bitop(
        self, keys: "Iterable[KeyT]", operation: "StringT", destkey: "KeyT"
    ) -> ClusterPipeline: ...
    async def bitpos(
        self,
        key: "KeyT",
        bit: "int",
        start: "Optional[int]" = None,
        end: "Optional[int]" = None,
        end_index_unit: "Optional[Literal[PureToken.BYTE, PureToken.BIT]]" = None,
    ) -> ClusterPipeline: ...
    async def getbit(self, key: "KeyT", offset: "int") -> ClusterPipeline: ...
    async def setbit(
        self, key: "KeyT", offset: "int", value: "int"
    ) -> ClusterPipeline: ...
    async def hdel(
        self, key: "KeyT", fields: "Iterable[StringT]"
    ) -> ClusterPipeline: ...
    async def hexists(self, key: "KeyT", field: "StringT") -> ClusterPipeline: ...
    async def hget(self, key: "KeyT", field: "StringT") -> ClusterPipeline: ...
    async def hgetall(self, key: "KeyT") -> ClusterPipeline: ...
    async def hincrby(
        self, key: "KeyT", field: "StringT", increment: "int"
    ) -> ClusterPipeline: ...
    async def hincrbyfloat(
        self, key: "KeyT", field: "StringT", increment: "Union[int, float]"
    ) -> ClusterPipeline: ...
    async def hkeys(self, key: "KeyT") -> ClusterPipeline: ...
    async def hlen(self, key: "KeyT") -> ClusterPipeline: ...
    async def hmget(
        self, key: "KeyT", fields: "Iterable[StringT]"
    ) -> ClusterPipeline: ...
    async def hmset(
        self, key: "KeyT", field_values: "Dict[StringT, ValueT]"
    ) -> ClusterPipeline: ...
    async def hrandfield(
        self,
        key: "KeyT",
        count: "Optional[int]" = None,
        withvalues: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def hscan(
        self,
        key: "KeyT",
        cursor: "Optional[int]" = 0,
        match: "Optional[StringT]" = None,
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def hset(
        self, key: "KeyT", field_values: "Dict[StringT, ValueT]"
    ) -> ClusterPipeline: ...
    async def hsetnx(
        self, key: "KeyT", field: "StringT", value: "ValueT"
    ) -> ClusterPipeline: ...
    async def hstrlen(self, key: "KeyT", field: "StringT") -> ClusterPipeline: ...
    async def hvals(self, key: "KeyT") -> ClusterPipeline: ...
    async def blmove(
        self,
        source: "KeyT",
        destination: "KeyT",
        wherefrom: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        whereto: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        timeout: "Union[int, float]",
    ) -> ClusterPipeline: ...
    async def blmpop(
        self,
        keys: "Iterable[KeyT]",
        timeout: "Union[int, float]",
        where: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def blpop(
        self, keys: "Iterable[KeyT]", timeout: "Union[int, float]"
    ) -> ClusterPipeline: ...
    async def brpop(
        self, keys: "Iterable[KeyT]", timeout: "Union[int, float]"
    ) -> ClusterPipeline: ...
    async def brpoplpush(
        self, source: "KeyT", destination: "KeyT", timeout: "Union[int, float]"
    ) -> ClusterPipeline: ...
    async def lindex(self, key: "KeyT", index: "int") -> ClusterPipeline: ...
    async def linsert(
        self,
        key: "KeyT",
        where: "Literal[PureToken.BEFORE, PureToken.AFTER]",
        pivot: "ValueT",
        element: "ValueT",
    ) -> ClusterPipeline: ...
    async def llen(self, key: "KeyT") -> ClusterPipeline: ...
    async def lmove(
        self,
        source: "KeyT",
        destination: "KeyT",
        wherefrom: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        whereto: "Literal[PureToken.LEFT, PureToken.RIGHT]",
    ) -> ClusterPipeline: ...
    async def lmpop(
        self,
        keys: "Iterable[Union[str, bytes]]",
        where: "Literal[PureToken.LEFT, PureToken.RIGHT]",
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def lpop(
        self, key: "KeyT", count: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def lpos(
        self,
        key: "KeyT",
        element: "ValueT",
        rank: "Optional[int]" = None,
        count: "Optional[int]" = None,
        maxlen: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def lpush(
        self, key: "KeyT", elements: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def lpushx(
        self, key: "KeyT", elements: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def lrange(
        self, key: "KeyT", start: "int", stop: "int"
    ) -> ClusterPipeline: ...
    async def lrem(
        self, key: "KeyT", count: "int", element: "ValueT"
    ) -> ClusterPipeline: ...
    async def lset(
        self, key: "KeyT", index: "int", element: "ValueT"
    ) -> ClusterPipeline: ...
    async def ltrim(
        self, key: "KeyT", start: "int", stop: "int"
    ) -> ClusterPipeline: ...
    async def rpop(
        self, key: "KeyT", count: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def rpoplpush(
        self, source: "KeyT", destination: "KeyT"
    ) -> ClusterPipeline: ...
    async def rpush(
        self, key: "KeyT", elements: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def rpushx(
        self, key: "KeyT", elements: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def sadd(
        self, key: "KeyT", members: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def scard(self, key: "KeyT") -> ClusterPipeline: ...
    async def sdiff(self, keys: "Iterable[KeyT]") -> ClusterPipeline: ...
    async def sdiffstore(
        self, keys: "Iterable[KeyT]", destination: "KeyT"
    ) -> ClusterPipeline: ...
    async def sinter(self, keys: "Iterable[KeyT]") -> ClusterPipeline: ...
    async def sintercard(
        self, keys: "Iterable[Union[str, bytes]]", limit: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def sinterstore(
        self, keys: "Iterable[KeyT]", destination: "KeyT"
    ) -> ClusterPipeline: ...
    async def sismember(self, key: "KeyT", member: "ValueT") -> ClusterPipeline: ...
    async def smembers(self, key: "KeyT") -> ClusterPipeline: ...
    async def smismember(
        self, key: "KeyT", members: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def smove(
        self, source: "KeyT", destination: "KeyT", member: "ValueT"
    ) -> ClusterPipeline: ...
    async def spop(
        self, key: "KeyT", count: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def srandmember(
        self, key: "KeyT", count: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def srem(
        self, key: "KeyT", members: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def sscan(
        self,
        key: "KeyT",
        cursor: "Optional[int]" = 0,
        match: "Optional[StringT]" = None,
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def sunion(self, keys: "Iterable[KeyT]") -> ClusterPipeline: ...
    async def sunionstore(
        self, keys: "Iterable[KeyT]", destination: "KeyT"
    ) -> ClusterPipeline: ...
    async def bzmpop(
        self,
        keys: "Iterable[KeyT]",
        timeout: "Union[int, float]",
        where: "Literal[PureToken.MIN, PureToken.MAX]",
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def bzpopmax(
        self, keys: "Iterable[KeyT]", timeout: "Union[int, float]"
    ) -> ClusterPipeline: ...
    async def bzpopmin(
        self, keys: "Iterable[KeyT]", timeout: "Union[int, float]"
    ) -> ClusterPipeline: ...
    async def zadd(
        self,
        key: "KeyT",
        member_scores: "Dict[StringT, float]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX]]" = None,
        comparison: "Optional[Literal[PureToken.GT, PureToken.LT]]" = None,
        change: "Optional[bool]" = None,
        increment: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def zcard(self, key: "KeyT") -> ClusterPipeline: ...
    async def zcount(
        self, key: "KeyT", min_: "ValueT", max_: "ValueT"
    ) -> ClusterPipeline: ...
    async def zdiff(
        self, keys: "Iterable[KeyT]", withscores: "Optional[bool]" = None
    ) -> ClusterPipeline: ...
    async def zdiffstore(
        self, keys: "Iterable[KeyT]", destination: "KeyT"
    ) -> ClusterPipeline: ...
    async def zincrby(
        self, key: "KeyT", member: "ValueT", increment: "int"
    ) -> ClusterPipeline: ...
    async def zinter(
        self,
        keys: "Iterable[KeyT]",
        weights: "Optional[Iterable[int]]" = None,
        aggregate: "Optional[Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX]]" = None,
        withscores: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def zintercard(
        self, keys: "Iterable[KeyT]", limit: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def zinterstore(
        self,
        keys: "Iterable[KeyT]",
        destination: "KeyT",
        weights: "Optional[Iterable[int]]" = None,
        aggregate: "Optional[Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX]]" = None,
    ) -> ClusterPipeline: ...
    async def zlexcount(
        self, key: "KeyT", min_: "ValueT", max_: "ValueT"
    ) -> ClusterPipeline: ...
    async def zmpop(
        self,
        keys: "Iterable[KeyT]",
        where: "Literal[PureToken.MIN, PureToken.MAX]",
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def zmscore(
        self, key: "KeyT", members: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def zpopmax(
        self, key: "KeyT", count: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def zpopmin(
        self, key: "KeyT", count: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def zrandmember(
        self,
        key: "KeyT",
        count: "Optional[int]" = None,
        withscores: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def zrange(
        self,
        key: "KeyT",
        min_: "Union[int, ValueT]",
        max_: "Union[int, ValueT]",
        sortby: "Optional[Literal[PureToken.BYSCORE, PureToken.BYLEX]]" = None,
        rev: "Optional[bool]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
        withscores: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def zrangebylex(
        self,
        key: "KeyT",
        min_: "ValueT",
        max_: "ValueT",
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def zrangebyscore(
        self,
        key: "KeyT",
        min_: "Union[int, float]",
        max_: "Union[int, float]",
        withscores: "Optional[bool]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def zrangestore(
        self,
        dst: "KeyT",
        src: "KeyT",
        min_: "Union[int, ValueT]",
        max_: "Union[int, ValueT]",
        sortby: "Optional[Literal[PureToken.BYSCORE, PureToken.BYLEX]]" = None,
        rev: "Optional[bool]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def zrank(self, key: "KeyT", member: "ValueT") -> ClusterPipeline: ...
    async def zrem(
        self, key: "KeyT", members: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def zremrangebylex(
        self, key: "KeyT", min_: "ValueT", max_: "ValueT"
    ) -> ClusterPipeline: ...
    async def zremrangebyrank(
        self, key: "KeyT", start: "int", stop: "int"
    ) -> ClusterPipeline: ...
    async def zremrangebyscore(
        self, key: "KeyT", min_: "Union[int, float]", max_: "Union[int, float]"
    ) -> ClusterPipeline: ...
    async def zrevrange(
        self,
        key: "KeyT",
        start: "int",
        stop: "int",
        withscores: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def zrevrangebylex(
        self,
        key: "KeyT",
        max_: "ValueT",
        min_: "ValueT",
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def zrevrangebyscore(
        self,
        key: "KeyT",
        max_: "Union[int, float]",
        min_: "Union[int, float]",
        withscores: "Optional[bool]" = None,
        offset: "Optional[int]" = None,
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def zrevrank(self, key: "KeyT", member: "ValueT") -> ClusterPipeline: ...
    async def zscan(
        self,
        key: "KeyT",
        cursor: "Optional[int]" = 0,
        match: "Optional[StringT]" = None,
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def zscore(self, key: "KeyT", member: "ValueT") -> ClusterPipeline: ...
    async def zunion(
        self,
        keys: "Iterable[KeyT]",
        weights: "Optional[Iterable[int]]" = None,
        aggregate: "Optional[Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX]]" = None,
        withscores: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def zunionstore(
        self,
        keys: "Iterable[KeyT]",
        destination: "KeyT",
        weights: "Optional[Iterable[int]]" = None,
        aggregate: "Optional[Literal[PureToken.SUM, PureToken.MIN, PureToken.MAX]]" = None,
    ) -> ClusterPipeline: ...
    async def pfadd(self, key: "KeyT", *elements: "ValueT") -> ClusterPipeline: ...
    async def pfcount(self, keys: "Iterable[KeyT]") -> ClusterPipeline: ...
    async def pfmerge(
        self, destkey: "KeyT", sourcekeys: "Iterable[KeyT]"
    ) -> ClusterPipeline: ...
    async def geoadd(
        self,
        key: "KeyT",
        longitude_latitude_members: "Iterable[Tuple[Union[int, float], Union[int, float], ValueT]]",
        condition: "Optional[Literal[PureToken.NX, PureToken.XX]]" = None,
        change: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def geodist(
        self,
        key: "KeyT",
        member1: "StringT",
        member2: "StringT",
        unit: "Optional[Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]]" = None,
    ) -> ClusterPipeline: ...
    async def geohash(
        self, key: "KeyT", members: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def geopos(
        self, key: "KeyT", members: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def georadius(
        self,
        key: "KeyT",
        longitude: "Union[int, float]",
        latitude: "Union[int, float]",
        radius: "Union[int, float]",
        unit: "Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]",
        withcoord: "Optional[bool]" = None,
        withdist: "Optional[bool]" = None,
        withhash: "Optional[bool]" = None,
        count: "Optional[int]" = None,
        any_: "Optional[bool]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        store: "Optional[KeyT]" = None,
        storedist: "Optional[KeyT]" = None,
    ) -> ClusterPipeline: ...
    async def georadiusbymember(
        self,
        key: "KeyT",
        member: "ValueT",
        radius: "Union[int, float]",
        unit: "Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]",
        withcoord: "Optional[bool]" = None,
        withdist: "Optional[bool]" = None,
        withhash: "Optional[bool]" = None,
        count: "Optional[int]" = None,
        any_: "Optional[bool]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        store: "Optional[KeyT]" = None,
        storedist: "Optional[KeyT]" = None,
    ) -> ClusterPipeline: ...
    async def geosearch(
        self,
        key: "KeyT",
        member: "Optional[ValueT]" = None,
        longitude: "Optional[Union[int, float]]" = None,
        latitude: "Optional[Union[int, float]]" = None,
        radius: "Optional[Union[int, float]]" = None,
        circle_unit: "Optional[Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]]" = None,
        width: "Optional[Union[int, float]]" = None,
        height: "Optional[Union[int, float]]" = None,
        box_unit: "Optional[Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        count: "Optional[int]" = None,
        any_: "Optional[bool]" = None,
        withcoord: "Optional[bool]" = None,
        withdist: "Optional[bool]" = None,
        withhash: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def geosearchstore(
        self,
        destination: "KeyT",
        source: "KeyT",
        member: "Optional[ValueT]" = None,
        longitude: "Optional[Union[int, float]]" = None,
        latitude: "Optional[Union[int, float]]" = None,
        radius: "Optional[Union[int, float]]" = None,
        circle_unit: "Optional[Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]]" = None,
        width: "Optional[Union[int, float]]" = None,
        height: "Optional[Union[int, float]]" = None,
        box_unit: "Optional[Literal[PureToken.M, PureToken.KM, PureToken.FT, PureToken.MI]]" = None,
        order: "Optional[Literal[PureToken.ASC, PureToken.DESC]]" = None,
        count: "Optional[int]" = None,
        any_: "Optional[bool]" = None,
        storedist: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def xack(
        self, key: "KeyT", group: "StringT", identifiers: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def xadd(
        self,
        key: "KeyT",
        field_values: "Dict[StringT, ValueT]",
        identifier: "Optional[ValueT]" = None,
        nomkstream: "Optional[bool]" = None,
        trim_strategy: "Optional[Literal[PureToken.MAXLEN, PureToken.MINID]]" = None,
        threshold: "Optional[int]" = None,
        trim_operator: "Optional[Literal[PureToken.EQUAL, PureToken.APPROXIMATELY]]" = None,
        limit: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def xautoclaim(
        self,
        key: "KeyT",
        group: "StringT",
        consumer: "StringT",
        min_idle_time: "Union[int, datetime.timedelta]",
        start: "ValueT",
        count: "Optional[int]" = None,
        justid: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def xclaim(
        self,
        key: "KeyT",
        group: "StringT",
        consumer: "StringT",
        min_idle_time: "Union[int, datetime.timedelta]",
        identifiers: "Iterable[ValueT]",
        idle: "Optional[int]" = None,
        time: "Optional[Union[int, datetime.datetime]]" = None,
        retrycount: "Optional[int]" = None,
        force: "Optional[bool]" = None,
        justid: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def xdel(
        self, key: "KeyT", identifiers: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def xgroup_create(
        self,
        key: "KeyT",
        groupname: "StringT",
        identifier: "Optional[ValueT]" = None,
        mkstream: "Optional[bool]" = None,
        entriesread: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def xgroup_createconsumer(
        self, key: "KeyT", groupname: "StringT", consumername: "StringT"
    ) -> ClusterPipeline: ...
    async def xgroup_delconsumer(
        self, key: "KeyT", groupname: "StringT", consumername: "StringT"
    ) -> ClusterPipeline: ...
    async def xgroup_destroy(
        self, key: "KeyT", groupname: "StringT"
    ) -> ClusterPipeline: ...
    async def xgroup_setid(
        self,
        key: "KeyT",
        groupname: "StringT",
        identifier: "Optional[ValueT]" = None,
        entriesread: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def xinfo_consumers(
        self, key: "KeyT", groupname: "StringT"
    ) -> ClusterPipeline: ...
    async def xinfo_groups(self, key: "KeyT") -> ClusterPipeline: ...
    async def xinfo_stream(
        self, key: "KeyT", full: "Optional[bool]" = None, count: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def xlen(self, key: "KeyT") -> ClusterPipeline: ...
    async def xpending(
        self,
        key: "KeyT",
        group: "StringT",
        start: "Optional[ValueT]" = None,
        end: "Optional[ValueT]" = None,
        count: "Optional[int]" = None,
        idle: "Optional[int]" = None,
        consumer: "Optional[StringT]" = None,
    ) -> ClusterPipeline: ...
    async def xrange(
        self,
        key: "KeyT",
        start: "Optional[ValueT]" = None,
        end: "Optional[ValueT]" = None,
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def xread(
        self,
        streams: "Dict[ValueT, ValueT]",
        count: "Optional[int]" = None,
        block: "Optional[Union[int, datetime.timedelta]]" = None,
    ) -> ClusterPipeline: ...
    async def xreadgroup(
        self,
        group: "StringT",
        consumer: "StringT",
        streams: "Dict[ValueT, ValueT]",
        count: "Optional[int]" = None,
        block: "Optional[Union[int, datetime.timedelta]]" = None,
        noack: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def xrevrange(
        self,
        key: "KeyT",
        end: "Optional[ValueT]" = None,
        start: "Optional[ValueT]" = None,
        count: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def xtrim(
        self,
        key: "KeyT",
        trim_strategy: "Literal[PureToken.MAXLEN, PureToken.MINID]",
        threshold: "int",
        trim_operator: "Optional[Literal[PureToken.EQUAL, PureToken.APPROXIMATELY]]" = None,
        limit: "Optional[int]" = None,
    ) -> ClusterPipeline: ...
    async def eval(
        self,
        script: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> ClusterPipeline: ...
    async def evalsha(
        self,
        sha1: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> ClusterPipeline: ...
    async def evalsha_ro(
        self,
        sha1: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> ClusterPipeline: ...
    async def eval_ro(
        self,
        script: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> ClusterPipeline: ...
    async def fcall(
        self,
        function: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> ClusterPipeline: ...
    async def fcall_ro(
        self,
        function: "StringT",
        keys: "Optional[Iterable[KeyT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> ClusterPipeline: ...
    async def function_delete(self, library_name: "StringT") -> ClusterPipeline: ...
    async def function_dump(self) -> ClusterPipeline: ...
    async def function_flush(
        self, async_: "Optional[Literal[PureToken.SYNC, PureToken.ASYNC]]" = None
    ) -> ClusterPipeline: ...
    async def function_kill(self) -> ClusterPipeline: ...
    async def function_list(
        self, libraryname: "Optional[StringT]" = None, withcode: "Optional[bool]" = None
    ) -> ClusterPipeline: ...
    async def function_load(
        self, function_code: "StringT", replace: "Optional[bool]" = None
    ) -> ClusterPipeline: ...
    async def function_restore(
        self,
        serialized_value: "bytes",
        policy: "Optional[Literal[PureToken.FLUSH, PureToken.APPEND, PureToken.REPLACE]]" = None,
    ) -> ClusterPipeline: ...
    async def function_stats(self) -> ClusterPipeline: ...
    async def script_debug(
        self, mode: "Literal[PureToken.YES, PureToken.SYNC, PureToken.NO]"
    ) -> ClusterPipeline: ...
    async def script_exists(self, sha1s: "Iterable[StringT]") -> ClusterPipeline: ...
    async def script_flush(
        self, sync_type: "Optional[Literal[PureToken.SYNC, PureToken.ASYNC]]" = None
    ) -> ClusterPipeline: ...
    async def script_kill(self) -> ClusterPipeline: ...
    async def script_load(self, script: "StringT") -> ClusterPipeline: ...
    async def publish(
        self, channel: "StringT", message: "StringT"
    ) -> ClusterPipeline: ...
    async def pubsub_channels(
        self, pattern: "Optional[StringT]" = None
    ) -> ClusterPipeline: ...
    async def pubsub_numpat(self) -> ClusterPipeline: ...
    async def pubsub_numsub(self, *channels: "StringT") -> ClusterPipeline: ...
    async def acl_cat(
        self, categoryname: "Optional[StringT]" = None
    ) -> ClusterPipeline: ...
    async def acl_deluser(self, usernames: "Iterable[StringT]") -> ClusterPipeline: ...
    async def acl_dryrun(
        self, username: "StringT", command: "StringT", *args: "ValueT"
    ) -> ClusterPipeline: ...
    async def acl_genpass(self, bits: "Optional[int]" = None) -> ClusterPipeline: ...
    async def acl_getuser(self, username: "StringT") -> ClusterPipeline: ...
    async def acl_list(self) -> ClusterPipeline: ...
    async def acl_load(self) -> ClusterPipeline: ...
    async def acl_log(
        self, count: "Optional[int]" = None, reset: "Optional[bool]" = None
    ) -> ClusterPipeline: ...
    async def acl_save(self) -> ClusterPipeline: ...
    async def acl_setuser(
        self, username: "StringT", *rules: "StringT"
    ) -> ClusterPipeline: ...
    async def acl_users(self) -> ClusterPipeline: ...
    async def acl_whoami(self) -> ClusterPipeline: ...
    async def bgrewriteaof(self) -> ClusterPipeline: ...
    async def bgsave(self, schedule: "Optional[bool]" = None) -> ClusterPipeline: ...
    async def command(self) -> ClusterPipeline: ...
    async def command_count(self) -> ClusterPipeline: ...
    async def command_docs(self, *command_names: "StringT") -> ClusterPipeline: ...
    async def command_getkeys(
        self, command: "StringT", arguments: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def command_getkeysandflags(
        self, command: "StringT", arguments: "Iterable[ValueT]"
    ) -> ClusterPipeline: ...
    async def command_info(self, *command_names: "StringT") -> ClusterPipeline: ...
    async def command_list(
        self,
        module: "Optional[StringT]" = None,
        aclcat: "Optional[StringT]" = None,
        pattern: "Optional[StringT]" = None,
    ) -> ClusterPipeline: ...
    async def config_get(self, parameters: "Iterable[StringT]") -> ClusterPipeline: ...
    async def config_resetstat(self) -> ClusterPipeline: ...
    async def config_rewrite(self) -> ClusterPipeline: ...
    async def config_set(
        self, parameter_values: "Dict[StringT, ValueT]"
    ) -> ClusterPipeline: ...
    async def dbsize(self) -> ClusterPipeline: ...
    async def failover(
        self,
        host: "Optional[StringT]" = None,
        port: "Optional[int]" = None,
        force: "Optional[bool]" = None,
        abort: "Optional[bool]" = None,
        timeout: "Optional[Union[int, datetime.timedelta]]" = None,
    ) -> ClusterPipeline: ...
    async def flushall(
        self, async_: "Optional[Literal[PureToken.ASYNC, PureToken.SYNC]]" = None
    ) -> ClusterPipeline: ...
    async def flushdb(
        self, async_: "Optional[Literal[PureToken.ASYNC, PureToken.SYNC]]" = None
    ) -> ClusterPipeline: ...
    async def info(self, *sections: "StringT") -> ClusterPipeline: ...
    async def lastsave(self) -> ClusterPipeline: ...
    async def latency_doctor(self) -> ClusterPipeline: ...
    async def latency_graph(self, event: "StringT") -> ClusterPipeline: ...
    async def latency_histogram(
        self, *commands: "Union[str, bytes]"
    ) -> ClusterPipeline: ...
    async def latency_history(self, event: "StringT") -> ClusterPipeline: ...
    async def latency_latest(self) -> ClusterPipeline: ...
    async def latency_reset(self, *events: "StringT") -> ClusterPipeline: ...
    async def lolwut(self, version: "Optional[int]" = None) -> ClusterPipeline: ...
    async def memory_doctor(self) -> ClusterPipeline: ...
    async def memory_malloc_stats(self) -> ClusterPipeline: ...
    async def memory_purge(self) -> ClusterPipeline: ...
    async def memory_stats(self) -> ClusterPipeline: ...
    async def memory_usage(
        self, key: "KeyT", samples: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def module_list(self) -> ClusterPipeline: ...
    async def module_load(
        self, path: "Union[str, bytes]", *args: "Union[str, bytes, int, float]"
    ) -> ClusterPipeline: ...
    async def module_loadex(
        self,
        path: "Union[str, bytes]",
        configs: "Optional[Dict[StringT, ValueT]]" = None,
        args: "Optional[Iterable[ValueT]]" = None,
    ) -> ClusterPipeline: ...
    async def module_unload(self, name: "Union[str, bytes]") -> ClusterPipeline: ...
    async def replicaof(
        self, host: "Optional[StringT]" = None, port: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def role(self) -> ClusterPipeline: ...
    async def save(self) -> ClusterPipeline: ...
    async def shutdown(
        self,
        nosave_save: "Optional[Literal[PureToken.NOSAVE, PureToken.SAVE]]" = None,
        now: "Optional[bool]" = None,
        force: "Optional[bool]" = None,
        abort: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def slaveof(
        self, host: "Optional[StringT]" = None, port: "Optional[int]" = None
    ) -> ClusterPipeline: ...
    async def slowlog_get(self, count: "Optional[int]" = None) -> ClusterPipeline: ...
    async def slowlog_len(self) -> ClusterPipeline: ...
    async def slowlog_reset(self) -> ClusterPipeline: ...
    async def swapdb(self, index1: "int", index2: "int") -> ClusterPipeline: ...
    async def time(self) -> ClusterPipeline: ...
    async def auth(
        self, password: "StringT", username: "Optional[StringT]" = None
    ) -> ClusterPipeline: ...
    async def client_caching(
        self, mode: "Literal[PureToken.YES, PureToken.NO]"
    ) -> ClusterPipeline: ...
    async def client_getname(self) -> ClusterPipeline: ...
    async def client_getredir(self) -> ClusterPipeline: ...
    async def client_id(self) -> ClusterPipeline: ...
    async def client_info(self) -> ClusterPipeline: ...
    async def client_kill(
        self,
        ip_port: "Optional[StringT]" = None,
        identifier: "Optional[int]" = None,
        type_: "Optional[Literal[PureToken.NORMAL, PureToken.MASTER, PureToken.SLAVE, PureToken.REPLICA, PureToken.PUBSUB]]" = None,
        user: "Optional[StringT]" = None,
        addr: "Optional[StringT]" = None,
        laddr: "Optional[StringT]" = None,
        skipme: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def client_list(
        self,
        type_: "Optional[Literal[PureToken.NORMAL, PureToken.MASTER, PureToken.REPLICA, PureToken.PUBSUB]]" = None,
        identifiers: "Optional[Iterable[int]]" = None,
    ) -> ClusterPipeline: ...
    async def client_no_evict(
        self, enabled: "Literal[PureToken.ON, PureToken.OFF]"
    ) -> ClusterPipeline: ...
    async def client_pause(
        self,
        timeout: "int",
        mode: "Optional[Literal[PureToken.WRITE, PureToken.ALL]]" = None,
    ) -> ClusterPipeline: ...
    async def client_reply(
        self, mode: "Literal[PureToken.ON, PureToken.OFF, PureToken.SKIP]"
    ) -> ClusterPipeline: ...
    async def client_setname(self, connection_name: "StringT") -> ClusterPipeline: ...
    async def client_tracking(
        self,
        status: "Literal[PureToken.ON, PureToken.OFF]",
        *prefixes: "StringT",
        redirect: "Optional[int]" = None,
        bcast: "Optional[bool]" = None,
        optin: "Optional[bool]" = None,
        optout: "Optional[bool]" = None,
        noloop: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def client_trackinginfo(self) -> ClusterPipeline: ...
    async def client_unblock(
        self,
        client_id: "int",
        timeout_error: "Optional[Literal[PureToken.TIMEOUT, PureToken.ERROR]]" = None,
    ) -> ClusterPipeline: ...
    async def client_unpause(self) -> ClusterPipeline: ...
    async def echo(self, message: "StringT") -> ClusterPipeline: ...
    async def hello(
        self,
        protover: "Optional[int]" = None,
        username: "Optional[StringT]" = None,
        password: "Optional[StringT]" = None,
        setname: "Optional[StringT]" = None,
    ) -> ClusterPipeline: ...
    async def ping(self, message: "Optional[StringT]" = None) -> ClusterPipeline: ...
    async def quit(self) -> ClusterPipeline: ...
    async def reset(self) -> ClusterPipeline: ...
    async def select(self, index: "int") -> ClusterPipeline: ...
    async def asking(self) -> ClusterPipeline: ...
    async def cluster_addslots(self, slots: "Iterable[int]") -> ClusterPipeline: ...
    async def cluster_addslotsrange(
        self, slots: "Iterable[Tuple[int, int]]"
    ) -> ClusterPipeline: ...
    async def cluster_bumpepoch(self) -> ClusterPipeline: ...
    async def cluster_count_failure_reports(
        self, node_id: "StringT"
    ) -> ClusterPipeline: ...
    async def cluster_countkeysinslot(self, slot: "int") -> ClusterPipeline: ...
    async def cluster_delslots(self, slots: "Iterable[int]") -> ClusterPipeline: ...
    async def cluster_delslotsrange(
        self, slots: "Iterable[Tuple[int, int]]"
    ) -> ClusterPipeline: ...
    async def cluster_failover(
        self, options: "Optional[Literal[PureToken.FORCE, PureToken.TAKEOVER]]" = None
    ) -> ClusterPipeline: ...
    async def cluster_flushslots(self) -> ClusterPipeline: ...
    async def cluster_forget(self, node_id: "StringT") -> ClusterPipeline: ...
    async def cluster_getkeysinslot(
        self, slot: "int", count: "int"
    ) -> ClusterPipeline: ...
    async def cluster_info(self) -> ClusterPipeline: ...
    async def cluster_keyslot(self, key: "KeyT") -> ClusterPipeline: ...
    async def cluster_links(self) -> ClusterPipeline: ...
    async def cluster_meet(self, ip: "StringT", port: "int") -> ClusterPipeline: ...
    async def cluster_myid(self) -> ClusterPipeline: ...
    async def cluster_nodes(self) -> ClusterPipeline: ...
    async def cluster_replicas(self, node_id: "StringT") -> ClusterPipeline: ...
    async def cluster_replicate(self, node_id: "StringT") -> ClusterPipeline: ...
    async def cluster_reset(
        self, hard_soft: "Optional[Literal[PureToken.HARD, PureToken.SOFT]]" = None
    ) -> ClusterPipeline: ...
    async def cluster_saveconfig(self) -> ClusterPipeline: ...
    async def cluster_set_config_epoch(
        self, config_epoch: "int"
    ) -> ClusterPipeline: ...
    async def cluster_setslot(
        self,
        slot: "int",
        importing: "Optional[StringT]" = None,
        migrating: "Optional[StringT]" = None,
        node: "Optional[StringT]" = None,
        stable: "Optional[bool]" = None,
    ) -> ClusterPipeline: ...
    async def cluster_shards(self) -> ClusterPipeline: ...
    async def cluster_slaves(self, node_id: "StringT") -> ClusterPipeline: ...
    async def cluster_slots(self) -> ClusterPipeline: ...
    async def readonly(self) -> ClusterPipeline: ...
    async def readwrite(self) -> ClusterPipeline: ...
    async def watch(self, *keys: "KeyT") -> bool: ...
    async def unwatch(*args, **kwargs): ...
    def multi(*args, **kwargs): ...
    async def execute(self, raise_on_error=True) -> Tuple[Any, ...]: ...
    async def __aenter__(self) -> "ClusterPipeline[AnyStr]": ...
    async def __aexit__(self, exc_type, exc_val, exc_tb): ...
