{"version":3,"file":"static/js/545.6d8f41d4.chunk.js","mappings":"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","sources":["../../core/src/asset-graph/Utils.tsx","../../core/src/asset-graph/layout.ts"],"sourcesContent":["import {gql} from '@apollo/client';\nimport {pathVerticalDiagonal} from '@vx/shape';\n\nimport {AssetNodeDefinitionFragment} from '../assets/types/AssetNodeDefinitionFragment';\n\nimport {AssetGraphLiveQuery_assetNodes_assetMaterializations} from './types/AssetGraphLiveQuery';\nimport {\n  AssetGraphQuery_assetNodes,\n  AssetGraphQuery_assetNodes_assetKey,\n} from './types/AssetGraphQuery';\nimport {AssetNodeLiveFragment} from './types/AssetNodeLiveFragment';\nimport {\n  RepositoryLiveFragment,\n  RepositoryLiveFragment_latestRunByStep_run,\n} from './types/RepositoryLiveFragment';\n\ntype AssetNode = AssetGraphQuery_assetNodes;\ntype AssetKey = AssetGraphQuery_assetNodes_assetKey;\n\nexport const __ASSET_GROUP_PREFIX = '__ASSET_GROUP';\n\nexport function isAssetGroup(jobName: string) {\n  return jobName.startsWith(__ASSET_GROUP_PREFIX);\n}\n\n// IMPORTANT: We use this, rather than AssetNode.id throughout this file because\n// the GraphQL interface exposes dependencyKeys, not dependencyIds. We also need\n// ways to \"build\" GraphId's locally, they can't always be server-provided.\n//\n// This value is NOT the same as AssetNode.id values provided by the server,\n// because JSON.stringify's whitespace behavior is different than Python's.\n//\nexport type GraphId = string;\nexport const toGraphId = (key: AssetKey): GraphId => JSON.stringify(key.path);\n\nexport interface GraphNode {\n  id: GraphId;\n  assetKey: AssetKey;\n  definition: AssetNode;\n}\n\nexport interface GraphData {\n  nodes: {[assetId: GraphId]: GraphNode};\n  downstream: {[assetId: GraphId]: {[childAssetId: GraphId]: boolean}};\n  upstream: {[assetId: GraphId]: {[parentAssetId: GraphId]: boolean}};\n}\nexport const isSourceAsset = (node: {jobNames: string[]; opName: string | null}) => {\n  return node.jobNames.length === 0 && !node.opName;\n};\n\nexport const buildGraphData = (assetNodes: AssetNode[]) => {\n  const data: GraphData = {\n    nodes: {},\n    downstream: {},\n    upstream: {},\n  };\n\n  const addEdge = (upstreamGraphId: string, downstreamGraphId: string) => {\n    data.downstream[upstreamGraphId] = {\n      ...(data.downstream[upstreamGraphId] || {}),\n      [downstreamGraphId]: true,\n    };\n    data.upstream[downstreamGraphId] = {\n      ...(data.upstream[downstreamGraphId] || {}),\n      [upstreamGraphId]: true,\n    };\n  };\n\n  assetNodes.forEach((definition: AssetNode) => {\n    const id = toGraphId(definition.assetKey);\n    definition.dependencyKeys.forEach((key) => {\n      addEdge(toGraphId(key), id);\n    });\n    definition.dependedByKeys.forEach((key) => {\n      addEdge(id, toGraphId(key));\n    });\n\n    data.nodes[id] = {\n      id,\n      assetKey: definition.assetKey,\n      definition,\n    };\n  });\n\n  return data;\n};\n\nexport const buildGraphDataFromSingleNode = (assetNode: AssetNodeDefinitionFragment) => {\n  const id = toGraphId(assetNode.assetKey);\n  const graphData: GraphData = {\n    downstream: {\n      [id]: {},\n    },\n    nodes: {\n      [id]: {\n        id,\n        assetKey: assetNode.assetKey,\n        definition: {...assetNode, dependencyKeys: [], dependedByKeys: []},\n      },\n    },\n    upstream: {\n      [id]: {},\n    },\n  };\n\n  for (const {asset} of assetNode.dependencies) {\n    const depId = toGraphId(asset.assetKey);\n    graphData.upstream[id][depId] = true;\n    graphData.downstream[depId] = {...graphData.downstream[depId], [id]: true};\n    graphData.nodes[depId] = {\n      id: depId,\n      assetKey: asset.assetKey,\n      definition: {...asset, dependencyKeys: [], dependedByKeys: []},\n    };\n  }\n  for (const {asset} of assetNode.dependedBy) {\n    const depId = toGraphId(asset.assetKey);\n    graphData.upstream[depId] = {...graphData.upstream[depId], [id]: true};\n    graphData.downstream[id][depId] = true;\n    graphData.nodes[depId] = {\n      id: depId,\n      assetKey: asset.assetKey,\n      definition: {...asset, dependencyKeys: [], dependedByKeys: []},\n    };\n  }\n  return graphData;\n};\n\nexport const graphHasCycles = (graphData: GraphData) => {\n  const nodes = new Set(Object.keys(graphData.nodes));\n  const search = (stack: string[], node: string): boolean => {\n    if (stack.indexOf(node) !== -1) {\n      return true;\n    }\n    if (nodes.delete(node) === true) {\n      const nextStack = stack.concat(node);\n      return Object.keys(graphData.downstream[node] || {}).some((nextNode) =>\n        search(nextStack, nextNode),\n      );\n    }\n    return false;\n  };\n  let hasCycles = false;\n  while (nodes.size !== 0) {\n    hasCycles = hasCycles || search([], nodes.values().next().value);\n  }\n  return hasCycles;\n};\n\nexport const buildSVGPath = pathVerticalDiagonal({\n  source: (s: any) => s.source,\n  target: (s: any) => s.target,\n  x: (s: any) => s.x,\n  y: (s: any) => s.y,\n});\n\nexport type Status = 'good' | 'old' | 'none' | 'unknown';\n\nexport interface LiveDataForNode {\n  computeStatus: Status;\n  unstartedRunIds: string[]; // run in progress and step not started\n  inProgressRunIds: string[]; // run in progress and step in progress\n  runWhichFailedToMaterialize: RepositoryLiveFragment_latestRunByStep_run | null;\n  lastMaterialization: AssetGraphLiveQuery_assetNodes_assetMaterializations | null;\n  lastChanged: number;\n}\nexport interface LiveData {\n  [assetId: GraphId]: LiveDataForNode;\n}\n\nexport const buildLiveData = (\n  graph: GraphData,\n  nodes: AssetNodeLiveFragment[],\n  repos: RepositoryLiveFragment[],\n) => {\n  const data: LiveData = {};\n\n  for (const liveNode of nodes) {\n    const graphId = toGraphId(liveNode.assetKey);\n    const graphNode = graph.nodes[graphId];\n    if (!graphNode) {\n      console.warn(`buildLiveData could not find the graph node matching ${graphId}`);\n      continue;\n    }\n    const lastMaterialization = liveNode.assetMaterializations[0] || null;\n    const lastChanged = Number(lastMaterialization?.timestamp || 0) / 1000;\n    const isPartitioned = graphNode.definition.partitionDefinition;\n    const repo = repos.find((r) => r.id === liveNode.repository.id);\n\n    const runs = repo?.inProgressRunsByStep.find((r) => r.stepKey === liveNode.opName);\n    const info = repo?.latestRunByStep.find((r) => r.stepKey === liveNode.opName);\n\n    const latestRunForStepKey = info?.__typename === 'LatestRun' ? info.run : null;\n\n    const runWhichFailedToMaterialize =\n      (latestRunForStepKey?.status === 'FAILURE' &&\n        (!lastMaterialization || lastMaterialization.runId !== latestRunForStepKey?.id) &&\n        latestRunForStepKey) ||\n      null;\n\n    data[graphId] = {\n      lastChanged,\n      lastMaterialization,\n      inProgressRunIds: runs?.inProgressRuns.map((r) => r.id) || [],\n      unstartedRunIds: runs?.unstartedRuns.map((r) => r.id) || [],\n      runWhichFailedToMaterialize,\n      computeStatus: isSourceAsset(graphNode.definition)\n        ? 'good' // foreign nodes are always considered up-to-date\n        : isPartitioned\n        ? // partitioned nodes are not supported, need to compare materializations\n          // of the same partition key and the API does not make fetching this easy\n          'none'\n        : lastMaterialization\n        ? 'unknown' // resolve to 'good' or 'old' by looking upstream\n        : 'none',\n    };\n  }\n\n  for (const liveNodeId of Object.keys(data)) {\n    data[liveNodeId].computeStatus = findComputeStatusForId(data, graph.upstream, liveNodeId);\n  }\n\n  return data;\n};\n\nfunction findComputeStatusForId(\n  data: LiveData,\n  upstream: {[assetId: string]: {[upstreamAssetId: string]: boolean}},\n  assetId: string,\n): Status {\n  if (!data[assetId]) {\n    // Currently compute status assumes foreign nodes are up to date\n    // and only shows \"upstream changed\" for upstreams in the same job\n    return 'good';\n  }\n  const ts = data[assetId].lastChanged;\n  const upstreamIds = Object.keys(upstream[assetId] || {});\n  if (data[assetId].computeStatus !== 'unknown') {\n    return data[assetId].computeStatus;\n  }\n\n  return upstreamIds.some((uid) => data[uid]?.lastChanged > ts)\n    ? 'old'\n    : upstreamIds.some((uid) => findComputeStatusForId(data, upstream, uid) !== 'good')\n    ? 'old'\n    : 'good';\n}\n\nexport function tokenForAssetKey(key: {path: string[]}) {\n  return key.path.join('>');\n}\n\nexport function displayNameForAssetKey(key: {path: string[]}) {\n  return key.path.join(' > ');\n}\n\nexport const IN_PROGRESS_RUNS_FRAGMENT = gql`\n  fragment InProgressRunsFragment on InProgressRunsByStep {\n    stepKey\n    unstartedRuns {\n      id\n    }\n    inProgressRuns {\n      id\n    }\n  }\n`;\n\nexport const LAST_RUNS_WARNINGS_FRAGMENT = gql`\n  fragment LastRunsWarningsFragment on LatestRun {\n    stepKey\n    run {\n      id\n      status\n    }\n  }\n`;\n\nexport const REPOSITORY_LIVE_FRAGMENT = gql`\n  fragment RepositoryLiveFragment on Repository {\n    id\n    name\n    location {\n      id\n      name\n    }\n    inProgressRunsByStep {\n      ...InProgressRunsFragment\n    }\n    latestRunByStep {\n      __typename\n      ...LastRunsWarningsFragment\n    }\n  }\n  ${IN_PROGRESS_RUNS_FRAGMENT}\n  ${LAST_RUNS_WARNINGS_FRAGMENT}\n`;\n","import * as dagre from 'dagre';\nimport uniq from 'lodash/uniq';\n\nimport {IBounds, IPoint} from '../graph/common';\n\nimport {GraphData, GraphNode, GraphId, displayNameForAssetKey} from './Utils';\n\nexport interface AssetLayout {\n  id: GraphId;\n\n  // Overall frame of the box relative to 0,0 on the graph\n  bounds: IBounds;\n}\n\nexport type AssetLayoutEdge = {\n  from: IPoint;\n  fromId: string;\n  to: IPoint;\n  toId: string;\n};\n\nexport type AssetGraphLayout = {\n  width: number;\n  height: number;\n  edges: AssetLayoutEdge[];\n  nodes: {[id: string]: AssetLayout};\n\n  bundleEdges: AssetLayoutEdge[];\n  bundles: {[id: string]: AssetLayout};\n};\n\nconst opts: {margin: number; mini: boolean} = {\n  margin: 100,\n  mini: false,\n};\n\nfunction identifyBundles(nodes: GraphNode[]) {\n  const pathPrefixes: {[prefixId: string]: string[]} = {};\n\n  for (const node of nodes) {\n    for (let ii = 1; ii < node.assetKey.path.length; ii++) {\n      const prefix = node.assetKey.path.slice(0, ii);\n      const key = JSON.stringify(prefix);\n      pathPrefixes[key] = pathPrefixes[key] || [];\n      pathPrefixes[key].push(node.id);\n    }\n  }\n\n  for (const key of Object.keys(pathPrefixes)) {\n    if (pathPrefixes[key].length <= 1) {\n      delete pathPrefixes[key];\n    }\n  }\n\n  const finalBundlePrefixes: {[prefixId: string]: string[]} = {};\n  const finalBundleIdForNodeId: {[id: string]: string} = {};\n\n  // Sort the prefix keys by length descending and iterate from the deepest folders first.\n  // Dedupe asset keys and replace asset keys we've already seen with the (deeper) folder\n  // they are within. This gets us \"multi layer folders\" of nodes.\n\n  // Turn this:\n  // {\n  //  \"s3\": [[\"s3\", \"collect\"], [\"s3\", \"prod\", \"a\"], [\"s3\", \"prod\", \"b\"]],\n  //  \"s3/prod\": [\"s3\", \"prod\", \"a\"], [\"s3\", \"prod\", \"b\"]\n  // }\n\n  // Into this:\n  // {\n  //  \"s3/prod\": [\"s3\", \"prod\", \"a\"], [\"s3\", \"prod\", \"b\"]\n  //  \"s3\": [[\"s3\", \"collect\"], [\"s3\", \"prod\"]],\n  // }\n\n  for (const prefixId of Object.keys(pathPrefixes).sort((a, b) => b.length - a.length)) {\n    finalBundlePrefixes[prefixId] = uniq(\n      pathPrefixes[prefixId].map((p) =>\n        finalBundleIdForNodeId[p] ? finalBundleIdForNodeId[p] : p,\n      ),\n    );\n    finalBundlePrefixes[prefixId].forEach((id) => (finalBundleIdForNodeId[id] = prefixId));\n  }\n  return finalBundlePrefixes;\n}\n\nexport const layoutAssetGraph = (graphData: GraphData): AssetGraphLayout => {\n  const g = new dagre.graphlib.Graph({compound: true});\n\n  g.setGraph({\n    rankdir: 'TB',\n    marginx: opts.margin,\n    marginy: opts.margin,\n    nodesep: opts.mini ? 20 : 50,\n    edgesep: opts.mini ? 10 : 10,\n    ranksep: opts.mini ? 20 : 50,\n  });\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const shouldRender = (node?: GraphNode) => node && node.definition.opName;\n\n  Object.values(graphData.nodes)\n    .filter(shouldRender)\n    .forEach((node) => {\n      const {width, height} = getAssetNodeDimensions(node.definition);\n      g.setNode(node.id, {width: opts.mini ? 230 : width, height});\n    });\n\n  const bundleMapping = identifyBundles(Object.values(graphData.nodes));\n  for (const [parentId, nodeIds] of Object.entries(bundleMapping)) {\n    g.setNode(parentId, {});\n    for (const nodeId of nodeIds) {\n      g.setParent(nodeId, parentId);\n    }\n  }\n\n  const foreignNodes = {};\n\n  Object.keys(graphData.downstream).forEach((upstreamId) => {\n    const downstreamIds = Object.keys(graphData.downstream[upstreamId]);\n    downstreamIds.forEach((downstreamId) => {\n      if (\n        !shouldRender(graphData.nodes[downstreamId]) &&\n        !shouldRender(graphData.nodes[upstreamId])\n      ) {\n        return;\n      }\n\n      g.setEdge({v: upstreamId, w: downstreamId}, {weight: 1});\n\n      if (!shouldRender(graphData.nodes[downstreamId])) {\n        foreignNodes[downstreamId] = true;\n      } else if (!shouldRender(graphData.nodes[upstreamId])) {\n        foreignNodes[upstreamId] = true;\n      }\n    });\n  });\n\n  Object.keys(foreignNodes).forEach((id) => {\n    g.setNode(id, getForeignNodeDimensions(id));\n  });\n\n  dagre.layout(g);\n\n  const dagreNodesById: {[id: string]: dagre.Node} = {};\n  g.nodes().forEach((id) => {\n    const node = g.node(id);\n    if (!node) {\n      return;\n    }\n    dagreNodesById[id] = node;\n  });\n\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  const nodes: {[id: string]: AssetLayout} = {};\n  const bundles: {[id: string]: AssetLayout} = {};\n\n  Object.keys(dagreNodesById).forEach((id) => {\n    const dagreNode = dagreNodesById[id];\n    const bounds = {\n      x: dagreNode.x - dagreNode.width / 2,\n      y: dagreNode.y - dagreNode.height / 2,\n      width: dagreNode.width,\n      height: dagreNode.height,\n    };\n    if (bundleMapping[id]) {\n      bundles[id] = {id, bounds};\n    } else {\n      nodes[id] = {id, bounds};\n    }\n    maxWidth = Math.max(maxWidth, dagreNode.x + dagreNode.width / 2);\n    maxHeight = Math.max(maxHeight, dagreNode.y + dagreNode.height / 2);\n  });\n\n  const edges: AssetLayoutEdge[] = [];\n  const bundleEdges: AssetLayoutEdge[] = [];\n\n  g.edges().forEach((e) => {\n    const points = g.edge(e).points;\n    if (bundles[e.v] || bundles[e.w]) {\n      bundleEdges.push({\n        from: points[0],\n        fromId: e.v,\n        to: points[points.length - 1],\n        toId: e.w,\n      });\n    } else {\n      edges.push({\n        from: points[0],\n        fromId: e.v,\n        to: points[points.length - 1],\n        toId: e.w,\n      });\n    }\n  });\n\n  return {\n    nodes,\n    edges,\n    bundles,\n    bundleEdges,\n    width: maxWidth + opts.margin,\n    height: maxHeight + opts.margin,\n  };\n};\n\nexport const getForeignNodeDimensions = (id: string) => {\n  const path = JSON.parse(id);\n  return {width: displayNameForAssetKey({path}).length * 8 + 30, height: 30};\n};\n\nexport const ASSET_NODE_ANNOTATIONS_MAX_WIDTH = 65;\nexport const ASSET_NODE_NAME_MAX_LENGTH = 32;\nconst DISPLAY_NAME_PX_PER_CHAR = 8.0;\n\nexport const getAssetNodeDimensions = (def: {\n  assetKey: {path: string[]};\n  opName: string | null;\n  description?: string | null;\n}) => {\n  let height = 75;\n  if (def.description) {\n    height += 25;\n  }\n  const displayName = displayNameForAssetKey(def.assetKey);\n  if (def.opName && displayName !== def.opName) {\n    height += 25;\n  }\n  return {\n    width:\n      Math.max(\n        200,\n        Math.min(ASSET_NODE_NAME_MAX_LENGTH, displayName.length) * DISPLAY_NAME_PX_PER_CHAR,\n      ) + ASSET_NODE_ANNOTATIONS_MAX_WIDTH,\n    height,\n  };\n};\n"],"names":["pathVerticalDiagonal","source","s","target","x","y","displayNameForAssetKey","key","path","join","IN_PROGRESS_RUNS_FRAGMENT","gql","LAST_RUNS_WARNINGS_FRAGMENT","opts","layoutAssetGraph","graphData","g","dagre","compound","setGraph","rankdir","marginx","marginy","nodesep","edgesep","ranksep","setDefaultEdgeLabel","shouldRender","node","definition","opName","Object","values","nodes","filter","forEach","getAssetNodeDimensions","width","height","setNode","id","bundleMapping","pathPrefixes","ii","assetKey","length","prefix","slice","JSON","stringify","push","keys","finalBundlePrefixes","finalBundleIdForNodeId","sort","a","b","prefixId","uniq","map","p","identifyBundles","entries","parentId","nodeIds","nodeId","setParent","foreignNodes","downstream","upstreamId","downstreamId","setEdge","v","w","weight","getForeignNodeDimensions","dagreNodesById","maxWidth","maxHeight","bundles","dagreNode","bounds","Math","max","edges","bundleEdges","e","points","edge","from","fromId","to","toId","parse","ASSET_NODE_ANNOTATIONS_MAX_WIDTH","ASSET_NODE_NAME_MAX_LENGTH","def","description","displayName","min"],"sourceRoot":""}