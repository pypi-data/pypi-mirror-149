# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Tell mypy (a type checker) to ignore all errors from this file.
# See https://mypy.readthedocs.io/en/stable/config_file.html?highlight=ignore-errors#confval-ignore_errors
# mypy: ignore-errors

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import json


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder():
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer after consuming")
        finally:
            self.free()


class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream(object):
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, rbuf):
        self.rbuf = rbuf
        self.offset = 0

    def remaining(self):
        return self.rbuf.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.rbuf.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.rbuf.len:
            raise InternalError("read past end of rust buffer")
        data = self.rbuf.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")


class RustBufferBuilder(object):
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FFIConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        return result
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.err_buf.contents.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, RustBuffer, ctypes.POINTER(RustBuffer))
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# This is how we find and load the dynamic library provided by the component.
# For now we just look it up by name.
#
# XXX TODO: This will probably grow some magic for resolving megazording in future.
# E.g. we might start by looking for the named component in `libuniffi.so` and if
# that fails, fall back to loading it separately from `lib${componentName}.so`.

from pathlib import Path

def loadIndirect():
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    lib = libname.format("engine_uniffi")
    path = str(Path(__file__).parent / lib)
    return ctypes.cdll.LoadLibrary(path)

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.ffi_engine_uniffi_99ea_HttpClient_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_engine_uniffi_99ea_HttpClient_object_free.restype = None
_UniFFILib.engine_uniffi_99ea_HttpClient_new.argtypes = (
    RustBuffer,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_HttpClient_new.restype = ctypes.c_void_p
_UniFFILib.engine_uniffi_99ea_HttpClient_set_header.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_HttpClient_set_header.restype = None
_UniFFILib.engine_uniffi_99ea_HttpClient_set_language.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_HttpClient_set_language.restype = None
_UniFFILib.engine_uniffi_99ea_HttpClient_set_url.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_HttpClient_set_url.restype = None
_UniFFILib.engine_uniffi_99ea_HttpClient_get.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_HttpClient_get.restype = RustBuffer
_UniFFILib.engine_uniffi_99ea_HttpClient_post.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_HttpClient_post.restype = RustBuffer
_UniFFILib.engine_uniffi_99ea_HttpClient_put.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_HttpClient_put.restype = RustBuffer
_UniFFILib.engine_uniffi_99ea_HttpClient_delete.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_HttpClient_delete.restype = RustBuffer
_UniFFILib.ffi_engine_uniffi_99ea_WsClient_object_free.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_engine_uniffi_99ea_WsClient_object_free.restype = None
_UniFFILib.engine_uniffi_99ea_WsClient_new.argtypes = (
    RustBuffer,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_WsClient_new.restype = ctypes.c_void_p
_UniFFILib.engine_uniffi_99ea_WsClient_ready_state.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_WsClient_ready_state.restype = RustBuffer
_UniFFILib.engine_uniffi_99ea_WsClient_reconnect.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_WsClient_reconnect.restype = None
_UniFFILib.engine_uniffi_99ea_WsClient_close.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_WsClient_close.restype = None
_UniFFILib.engine_uniffi_99ea_WsClient_send_request.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int32,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_WsClient_send_request.restype = RustBuffer
_UniFFILib.ffi_engine_uniffi_99ea_Binding_init_callback.argtypes = (
    FOREIGN_CALLBACK_T,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_engine_uniffi_99ea_Binding_init_callback.restype = None
_UniFFILib.ffi_engine_uniffi_99ea_Session_init_callback.argtypes = (
    FOREIGN_CALLBACK_T,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_engine_uniffi_99ea_Session_init_callback.restype = None
_UniFFILib.ffi_engine_uniffi_99ea_WsCallback_init_callback.argtypes = (
    FOREIGN_CALLBACK_T,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_engine_uniffi_99ea_WsCallback_init_callback.restype = None
_UniFFILib.engine_uniffi_99ea_init_engine.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.engine_uniffi_99ea_init_engine.restype = None
_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_free.restype = None
_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_engine_uniffi_99ea_rustbuffer_reserve.restype = RustBuffer

# Public interface members begin here.

import threading

class ConcurrentHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._left_map = {}  # type: Dict[Handle, Any]
        self._right_map = {}  # type: Dict[Any, Handle]

        self._lock = threading.Lock()
        self._current_handle = 0
        self._stride = 1


    def insert(self, obj):
        with self._lock:
            if obj in self._right_map:
                return self._right_map[obj]
            else:
                handle = self._current_handle
                self._current_handle += self._stride
                self._left_map[handle] = obj
                self._right_map[obj] = handle
                return handle

    def get(self, handle):
        with self._lock:
            return self._left_map.get(handle)

    def remove(self, handle):
        with self._lock:
            if handle in self._left_map:
                obj = self._left_map.pop(handle)
                del self._right_map[obj]
                return obj

# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
IDX_CALLBACK_FREE = 0

class FfiConverterCallbackInterface:
    _handle_map = ConcurrentHandleMap()

    def __init__(self, cb):
        self._foreign_callback = cb

    def drop(self, handle):
        self.__class__._handle_map.remove(handle)

    @classmethod
    def lift(cls, handle):
        obj = cls._handle_map.get(handle)
        if not obj:
            raise InternalError("The object in the handle map has been dropped already")

        return obj

    @classmethod
    def read(cls, buf):
        handle = buf.readU64()
        cls.lift(handle)

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.writeU64(cls.lower(cb))



class Env(enum.Enum):
    CANARY = 1
    PRE = 2
    PROD = 3
    


class FfiConverterTypeEnv(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return Env.CANARY
        if variant == 2:
            return Env.PRE
        if variant == 3:
            return Env.PROD
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == Env.CANARY:
            buf.writeI32(1)
        if value == Env.PRE:
            buf.writeI32(2)
        if value == Env.PROD:
            buf.writeI32(3)



class AppId(enum.Enum):
    UNKNOWN = 1
    IOS = 2
    ANDROID = 3
    DESKTOP = 4
    WHALE = 5
    TUI = 6
    OPENAPI = 7
    


class FfiConverterTypeAppId(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return AppId.UNKNOWN
        if variant == 2:
            return AppId.IOS
        if variant == 3:
            return AppId.ANDROID
        if variant == 4:
            return AppId.DESKTOP
        if variant == 5:
            return AppId.WHALE
        if variant == 6:
            return AppId.TUI
        if variant == 7:
            return AppId.OPENAPI
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == AppId.UNKNOWN:
            buf.writeI32(1)
        if value == AppId.IOS:
            buf.writeI32(2)
        if value == AppId.ANDROID:
            buf.writeI32(3)
        if value == AppId.DESKTOP:
            buf.writeI32(4)
        if value == AppId.WHALE:
            buf.writeI32(5)
        if value == AppId.TUI:
            buf.writeI32(6)
        if value == AppId.OPENAPI:
            buf.writeI32(7)



class ReadyState(enum.Enum):
    OPENING = 1
    OPEN = 2
    RECONNECTING = 3
    CLOSED = 4
    


class FfiConverterTypeReadyState(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ReadyState.OPENING
        if variant == 2:
            return ReadyState.OPEN
        if variant == 3:
            return ReadyState.RECONNECTING
        if variant == 4:
            return ReadyState.CLOSED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == ReadyState.OPENING:
            buf.writeI32(1)
        if value == ReadyState.OPEN:
            buf.writeI32(2)
        if value == ReadyState.RECONNECTING:
            buf.writeI32(3)
        if value == ReadyState.CLOSED:
            buf.writeI32(4)
def init_engine(app,device = None,platform = None):
    app = app
    device = (None if device is None else device)
    platform = (None if platform is None else platform)
    rust_call(_UniFFILib.engine_uniffi_99ea_init_engine,
        FfiConverterTypeAppInfo.lower(app),
        FfiConverterOptionalTypeDeviceInfo.lower(device),
        FfiConverterOptionalTypePlatformInfo.lower(platform))



class HttpClient(object):
    def __init__(self, config,binding,session):
        config = config
        binding = binding
        session = session
        self._pointer = rust_call(_UniFFILib.engine_uniffi_99ea_HttpClient_new,
        FfiConverterTypeHttpClientConfig.lower(config),
        FfiConverterCallbackInterfaceBinding.lower(binding),
        FfiConverterCallbackInterfaceSession.lower(session))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_engine_uniffi_99ea_HttpClient_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def set_header(self, key,value):
        key = key
        value = value
        rust_call(_UniFFILib.engine_uniffi_99ea_HttpClient_set_header,self._pointer,
        FfiConverterString.lower(key),
        FfiConverterString.lower(value))
    
    def set_language(self, language):
        language = language
        rust_call(_UniFFILib.engine_uniffi_99ea_HttpClient_set_language,self._pointer,
        FfiConverterString.lower(language))
    
    def set_url(self, base_url,env = None):
        base_url = base_url
        env = (None if env is None else env)
        rust_call(_UniFFILib.engine_uniffi_99ea_HttpClient_set_url,self._pointer,
        FfiConverterString.lower(base_url),
        FfiConverterOptionalTypeEnv.lower(env))
    
    def get(self, path,query = None,options = None):
        path = path
        query = (None if query is None else query)
        options = (None if options is None else options)
        return FfiConverterTypeApiResponse.lift(
            rust_call_with_error(
    FfiConverterTypeApiError,_UniFFILib.engine_uniffi_99ea_HttpClient_get,self._pointer,
        FfiConverterString.lower(path),
        FfiConverterOptionalTypeJson.lower(query),
        FfiConverterOptionalTypeRequestOption.lower(options))
        )
    def post(self, path,payload = None,options = None):
        path = path
        payload = (None if payload is None else payload)
        options = (None if options is None else options)
        return FfiConverterTypeApiResponse.lift(
            rust_call_with_error(
    FfiConverterTypeApiError,_UniFFILib.engine_uniffi_99ea_HttpClient_post,self._pointer,
        FfiConverterString.lower(path),
        FfiConverterOptionalTypeJson.lower(payload),
        FfiConverterOptionalTypeRequestOption.lower(options))
        )
    def put(self, path,payload = None,options = None):
        path = path
        payload = (None if payload is None else payload)
        options = (None if options is None else options)
        return FfiConverterTypeApiResponse.lift(
            rust_call_with_error(
    FfiConverterTypeApiError,_UniFFILib.engine_uniffi_99ea_HttpClient_put,self._pointer,
        FfiConverterString.lower(path),
        FfiConverterOptionalTypeJson.lower(payload),
        FfiConverterOptionalTypeRequestOption.lower(options))
        )
    def delete(self, path,query = None,options = None):
        path = path
        query = (None if query is None else query)
        options = (None if options is None else options)
        return FfiConverterTypeApiResponse.lift(
            rust_call_with_error(
    FfiConverterTypeApiError,_UniFFILib.engine_uniffi_99ea_HttpClient_delete,self._pointer,
        FfiConverterString.lower(path),
        FfiConverterOptionalTypeJson.lower(query),
        FfiConverterOptionalTypeRequestOption.lower(options))
        )
    


class FfiConverterTypeHttpClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, HttpClient):
            raise TypeError("Expected HttpClient instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return HttpClient._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class WsClient(object):
    def __init__(self, url,http,callback):
        url = url
        http = http
        callback = callback
        self._pointer = rust_call(_UniFFILib.engine_uniffi_99ea_WsClient_new,
        FfiConverterString.lower(url),
        FfiConverterTypeHttpClient.lower(http),
        FfiConverterCallbackInterfaceWsCallback.lower(callback))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.ffi_engine_uniffi_99ea_WsClient_object_free, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    

    def ready_state(self, ):
        return FfiConverterTypeReadyState.lift(
            rust_call(_UniFFILib.engine_uniffi_99ea_WsClient_ready_state,self._pointer,)
        )
    def reconnect(self, ):
        rust_call_with_error(
    FfiConverterTypeAnyhowError,_UniFFILib.engine_uniffi_99ea_WsClient_reconnect,self._pointer,)
    
    def close(self, ):
        rust_call_with_error(
    FfiConverterTypeAnyhowError,_UniFFILib.engine_uniffi_99ea_WsClient_close,self._pointer,)
    
    def send_request(self, command,payload,timeout = None):
        command = int(command)
        payload = payload
        timeout = (None if timeout is None else timeout)
        return FfiConverterTypeBytes.lift(
            rust_call_with_error(
    FfiConverterTypeApiError,_UniFFILib.engine_uniffi_99ea_WsClient_send_request,self._pointer,
        FfiConverterInt32.lower(command),
        FfiConverterTypeBytes.lower(payload),
        FfiConverterOptionalDuration.lower(timeout))
        )
    


class FfiConverterTypeWsClient:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, WsClient):
            raise TypeError("Expected WsClient instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return WsClient._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer

class AppInfo:
    def __init__(self, app_id, env, version = "", build = ""):
        self.app_id = app_id
        self.env = env
        self.version = version
        self.build = build

    def __str__(self):
        return "AppInfo(app_id={}, env={}, version={}, build={})".format(self.app_id, self.env, self.version, self.build)

    def __eq__(self, other):
        if self.app_id != other.app_id:
            return False
        if self.env != other.env:
            return False
        if self.version != other.version:
            return False
        if self.build != other.build:
            return False
        return True

class FfiConverterTypeAppInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AppInfo(
            app_id=FfiConverterTypeAppId.read(buf),
            env=FfiConverterTypeEnv.read(buf),
            version=FfiConverterString.read(buf),
            build=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeAppId.write(value.app_id, buf)
        FfiConverterTypeEnv.write(value.env, buf)
        FfiConverterString.write(value.version, buf)
        FfiConverterString.write(value.build, buf)

class DeviceInfo:
    def __init__(self, device_id = "", name = "", model = ""):
        self.device_id = device_id
        self.name = name
        self.model = model

    def __str__(self):
        return "DeviceInfo(device_id={}, name={}, model={})".format(self.device_id, self.name, self.model)

    def __eq__(self, other):
        if self.device_id != other.device_id:
            return False
        if self.name != other.name:
            return False
        if self.model != other.model:
            return False
        return True

class FfiConverterTypeDeviceInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DeviceInfo(
            device_id=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            model=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.device_id, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterString.write(value.model, buf)

class PlatformInfo:
    def __init__(self, name = "", system_version = ""):
        self.name = name
        self.system_version = system_version

    def __str__(self):
        return "PlatformInfo(name={}, system_version={})".format(self.name, self.system_version)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.system_version != other.system_version:
            return False
        return True

class FfiConverterTypePlatformInfo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PlatformInfo(
            name=FfiConverterString.read(buf),
            system_version=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.name, buf)
        FfiConverterString.write(value.system_version, buf)

class RequestOption:
    def __init__(self, headers, meta, timeout):
        self.headers = headers
        self.meta = meta
        self.timeout = timeout

    def __str__(self):
        return "RequestOption(headers={}, meta={}, timeout={})".format(self.headers, self.meta, self.timeout)

    def __eq__(self, other):
        if self.headers != other.headers:
            return False
        if self.meta != other.meta:
            return False
        if self.timeout != other.timeout:
            return False
        return True

class FfiConverterTypeRequestOption(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RequestOption(
            headers=FfiConverterMapStringString.read(buf),
            meta=FfiConverterMapStringString.read(buf),
            timeout=FfiConverterDuration.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterMapStringString.write(value.headers, buf)
        FfiConverterMapStringString.write(value.meta, buf)
        FfiConverterDuration.write(value.timeout, buf)

class ApiResponse:
    def __init__(self, headers, data):
        self.headers = headers
        self.data = data

    def __str__(self):
        return "ApiResponse(headers={}, data={})".format(self.headers, self.data)

    def __eq__(self, other):
        if self.headers != other.headers:
            return False
        if self.data != other.data:
            return False
        return True

class FfiConverterTypeApiResponse(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ApiResponse(
            headers=FfiConverterMapStringString.read(buf),
            data=FfiConverterTypeJson.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterMapStringString.write(value.headers, buf)
        FfiConverterTypeJson.write(value.data, buf)

class HttpClientConfig:
    def __init__(self, env, base_url, headers, beacon_url = None, language = "zh-CN", session_id = ""):
        self.env = env
        self.base_url = base_url
        self.headers = headers
        self.beacon_url = beacon_url
        self.language = language
        self.session_id = session_id

    def __str__(self):
        return "HttpClientConfig(env={}, base_url={}, headers={}, beacon_url={}, language={}, session_id={})".format(self.env, self.base_url, self.headers, self.beacon_url, self.language, self.session_id)

    def __eq__(self, other):
        if self.env != other.env:
            return False
        if self.base_url != other.base_url:
            return False
        if self.headers != other.headers:
            return False
        if self.beacon_url != other.beacon_url:
            return False
        if self.language != other.language:
            return False
        if self.session_id != other.session_id:
            return False
        return True

class FfiConverterTypeHttpClientConfig(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return HttpClientConfig(
            env=FfiConverterTypeEnv.read(buf),
            base_url=FfiConverterTypeUrl.read(buf),
            headers=FfiConverterTypeHeaderMap.read(buf),
            beacon_url=FfiConverterOptionalString.read(buf),
            language=FfiConverterString.read(buf),
            session_id=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeEnv.write(value.env, buf)
        FfiConverterTypeUrl.write(value.base_url, buf)
        FfiConverterTypeHeaderMap.write(value.headers, buf)
        FfiConverterOptionalString.write(value.beacon_url, buf)
        FfiConverterString.write(value.language, buf)
        FfiConverterString.write(value.session_id, buf)

class AnyhowError(Exception):

    # Each variant is a nested class of the error itself.
    # It just carries a string error message, so no special implementation is necessary.
    class Error(Exception):
        pass

class FfiConverterTypeAnyhowError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return AnyhowError.Error(
                FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, AnyhowError.Error):
            buf.writeI32(1)

class ApiError(Exception):

    # Each variant is a nested class of the error itself.
    class Request(Exception):
        def __init__(self, code, message):
            self.code = code
            self.message = message

        def __str__(self):
            field_parts = [
                'code={!r}'.format(self.code),
                'message={!r}'.format(self.message),
            ]
            return "ApiError.Request({})".format(', '.join(field_parts))
    class Http(Exception):
        def __init__(self, code, status, message, detail, trace_id, headers):
            self.code = code
            self.status = status
            self.message = message
            self.detail = detail
            self.trace_id = trace_id
            self.headers = headers

        def __str__(self):
            field_parts = [
                'code={!r}'.format(self.code),
                'status={!r}'.format(self.status),
                'message={!r}'.format(self.message),
                'detail={!r}'.format(self.detail),
                'trace_id={!r}'.format(self.trace_id),
                'headers={!r}'.format(self.headers),
            ]
            return "ApiError.Http({})".format(', '.join(field_parts))
    class WebSocket(Exception):
        def __init__(self, code, message):
            self.code = code
            self.message = message

        def __str__(self):
            field_parts = [
                'code={!r}'.format(self.code),
                'message={!r}'.format(self.message),
            ]
            return "ApiError.WebSocket({})".format(', '.join(field_parts))
    class Other(Exception):
        def __init__(self, code, message):
            self.code = code
            self.message = message

        def __str__(self):
            field_parts = [
                'code={!r}'.format(self.code),
                'message={!r}'.format(self.message),
            ]
            return "ApiError.Other({})".format(', '.join(field_parts))

class FfiConverterTypeApiError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return ApiError.Request(
                code=FfiConverterInt32.read(buf),
                message=FfiConverterString.read(buf),
            )
        if variant == 2:
            return ApiError.Http(
                code=FfiConverterInt32.read(buf),
                status=FfiConverterUInt16.read(buf),
                message=FfiConverterString.read(buf),
                detail=FfiConverterString.read(buf),
                trace_id=FfiConverterString.read(buf),
                headers=FfiConverterMapStringString.read(buf),
            )
        if variant == 3:
            return ApiError.WebSocket(
                code=FfiConverterUInt64.read(buf),
                message=FfiConverterString.read(buf),
            )
        if variant == 4:
            return ApiError.Other(
                code=FfiConverterInt32.read(buf),
                message=FfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, ApiError.Request):
            buf.writeI32(1)
            FfiConverterInt32.write(value.code, buf)
            FfiConverterString.write(value.message, buf)
        if isinstance(value, ApiError.Http):
            buf.writeI32(2)
            FfiConverterInt32.write(value.code, buf)
            FfiConverterUInt16.write(value.status, buf)
            FfiConverterString.write(value.message, buf)
            FfiConverterString.write(value.detail, buf)
            FfiConverterString.write(value.trace_id, buf)
            FfiConverterMapStringString.write(value.headers, buf)
        if isinstance(value, ApiError.WebSocket):
            buf.writeI32(3)
            FfiConverterUInt64.write(value.code, buf)
            FfiConverterString.write(value.message, buf)
        if isinstance(value, ApiError.Other):
            buf.writeI32(4)
            FfiConverterInt32.write(value.code, buf)
            FfiConverterString.write(value.message, buf)


# Declaration and FfiConverters for Binding Callback Interface

class Binding:
    def timestamp(path,timestamp):
        raise NotImplementedError

    def user_agent():
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceBinding(handle, method, args, buf_ptr):
    
    def invoke_timestamp(python_callback, args):
        rval = None
        with args.consumeWithStream() as buf:
            rval = python_callback.timestamp(
                FfiConverterString.read(buf), 
                FfiConverterString.read(buf)
                )
        with RustBuffer.allocWithBuilder() as builder:
            FfiConverterString.write(rval, builder)
            return builder.finalize()# TODO catch errors and report them back to Rust.
        # https://github.com/mozilla/uniffi-rs/issues/351
    
    def invoke_user_agent(python_callback, args):
        rval = None
        rval = python_callback.user_agent()
        with RustBuffer.allocWithBuilder() as builder:
            FfiConverterString.write(rval, builder)
            return builder.finalize()# TODO catch errors and report them back to Rust.
        # https://github.com/mozilla/uniffi-rs/issues/351
    

    cb = FfiConverterCallbackInterfaceBinding.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a Uniffi bug")

    if method == IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceBinding.drop(handle)
        # No return value.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 0

    if method == 1:
        buf_ptr[0] = invoke_timestamp(cb, args)
        # Value written to out buffer.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 1
    if method == 2:
        buf_ptr[0] = invoke_user_agent(cb, args)
        # Value written to out buffer.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 1
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
    return -1

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceBinding = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceBinding)

# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
rust_call(lambda err: _UniFFILib.ffi_engine_uniffi_99ea_Binding_init_callback(foreignCallbackCallbackInterfaceBinding, err))
FfiConverterCallbackInterfaceBinding = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceBinding)


# Declaration and FfiConverters for Session Callback Interface

class Session:
    def id():
        raise NotImplementedError

    def get(key):
        raise NotImplementedError

    def set(key,value):
        raise NotImplementedError

    def remove(key):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceSession(handle, method, args, buf_ptr):
    
    def invoke_id(python_callback, args):
        rval = None
        rval = python_callback.id()
        with RustBuffer.allocWithBuilder() as builder:
            FfiConverterString.write(rval, builder)
            return builder.finalize()# TODO catch errors and report them back to Rust.
        # https://github.com/mozilla/uniffi-rs/issues/351
    
    def invoke_get(python_callback, args):
        rval = None
        with args.consumeWithStream() as buf:
            rval = python_callback.get(
                FfiConverterString.read(buf)
                )
        with RustBuffer.allocWithBuilder() as builder:
            FfiConverterOptionalString.write(rval, builder)
            return builder.finalize()# TODO catch errors and report them back to Rust.
        # https://github.com/mozilla/uniffi-rs/issues/351
    
    def invoke_set(python_callback, args):
        rval = None
        with args.consumeWithStream() as buf:
            rval = python_callback.set(
                FfiConverterString.read(buf), 
                FfiConverterString.read(buf)
                )
        return RustBuffer.alloc(0)
        # TODO catch errors and report them back to Rust.
        # https://github.com/mozilla/uniffi-rs/issues/351
    
    def invoke_remove(python_callback, args):
        rval = None
        with args.consumeWithStream() as buf:
            rval = python_callback.remove(
                FfiConverterString.read(buf)
                )
        return RustBuffer.alloc(0)
        # TODO catch errors and report them back to Rust.
        # https://github.com/mozilla/uniffi-rs/issues/351
    

    cb = FfiConverterCallbackInterfaceSession.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a Uniffi bug")

    if method == IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceSession.drop(handle)
        # No return value.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 0

    if method == 1:
        buf_ptr[0] = invoke_id(cb, args)
        # Value written to out buffer.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 1
    if method == 2:
        buf_ptr[0] = invoke_get(cb, args)
        # Value written to out buffer.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 1
    if method == 3:
        buf_ptr[0] = invoke_set(cb, args)
        # Value written to out buffer.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 1
    if method == 4:
        buf_ptr[0] = invoke_remove(cb, args)
        # Value written to out buffer.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 1
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
    return -1

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceSession = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceSession)

# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
rust_call(lambda err: _UniFFILib.ffi_engine_uniffi_99ea_Session_init_callback(foreignCallbackCallbackInterfaceSession, err))
FfiConverterCallbackInterfaceSession = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceSession)


# Declaration and FfiConverters for WsCallback Callback Interface

class WsCallback:
    def on_push(command,payload):
        raise NotImplementedError

    def on_state(state):
        raise NotImplementedError

    

def py_foreignCallbackCallbackInterfaceWsCallback(handle, method, args, buf_ptr):
    
    def invoke_on_push(python_callback, args):
        rval = None
        with args.consumeWithStream() as buf:
            rval = python_callback.on_push(
                FfiConverterInt32.read(buf), 
                FfiConverterTypeBytes.read(buf)
                )
        return RustBuffer.alloc(0)
        # TODO catch errors and report them back to Rust.
        # https://github.com/mozilla/uniffi-rs/issues/351
    
    def invoke_on_state(python_callback, args):
        rval = None
        with args.consumeWithStream() as buf:
            rval = python_callback.on_state(
                FfiConverterTypeReadyState.read(buf)
                )
        return RustBuffer.alloc(0)
        # TODO catch errors and report them back to Rust.
        # https://github.com/mozilla/uniffi-rs/issues/351
    

    cb = FfiConverterCallbackInterfaceWsCallback.lift(handle)
    if not cb:
        raise InternalError("No callback in handlemap; this is a Uniffi bug")

    if method == IDX_CALLBACK_FREE:
        FfiConverterCallbackInterfaceWsCallback.drop(handle)
        # No return value.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 0

    if method == 1:
        buf_ptr[0] = invoke_on_push(cb, args)
        # Value written to out buffer.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 1
    if method == 2:
        buf_ptr[0] = invoke_on_state(cb, args)
        # Value written to out buffer.
        # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
        return 1
    

    # This should never happen, because an out of bounds method index won't
    # ever be used. Once we can catch errors, we should return an InternalException.
    # https://github.com/mozilla/uniffi-rs/issues/351

    # An unexpected error happened.
    # See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
    return -1

# We need to keep this function reference alive:
# if they get GC'd while in use then UniFFI internals could attempt to call a function
# that is in freed memory.
# That would be...uh...bad. Yeah, that's the word. Bad.
foreignCallbackCallbackInterfaceWsCallback = FOREIGN_CALLBACK_T(py_foreignCallbackCallbackInterfaceWsCallback)

# The FfiConverter which transforms the Callbacks in to Handles to pass to Rust.
rust_call(lambda err: _UniFFILib.ffi_engine_uniffi_99ea_WsCallback_init_callback(foreignCallbackCallbackInterfaceWsCallback, err))
FfiConverterCallbackInterfaceWsCallback = FfiConverterCallbackInterface(foreignCallbackCallbackInterfaceWsCallback)

class FfiConverterTypeBytes:
    @staticmethod
    def write(value, buf):
        builtin_value = list(value)
        FfiConverterSequenceUInt8.write(builtin_value, buf)

    @staticmethod
    def read(buf):
        builtin_value = FfiConverterSequenceUInt8.read(buf)
        return bytes(builtin_value)

    @staticmethod
    def lift(value):
        builtin_value = FfiConverterSequenceUInt8.lift(value)
        return bytes(builtin_value)

    @staticmethod
    def lower(value):
        builtin_value = list(value)
        return FfiConverterSequenceUInt8.lower(builtin_value)

class FfiConverterTypeHeaderMap:
    @staticmethod
    def write(value, buf):
        FfiConverterMapStringString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterMapStringString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterMapStringString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterMapStringString.lower(value)

class FfiConverterTypeJson:
    @staticmethod
    def write(value, buf):
        builtin_value = json.dumps(value)
        FfiConverterString.write(builtin_value, buf)

    @staticmethod
    def read(buf):
        builtin_value = FfiConverterString.read(buf)
        return json.loads(builtin_value)

    @staticmethod
    def lift(value):
        builtin_value = FfiConverterString.lift(value)
        return json.loads(builtin_value)

    @staticmethod
    def lower(value):
        builtin_value = json.dumps(value)
        return FfiConverterString.lower(builtin_value)

class FfiConverterTypeUrl:
    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return FfiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return FfiConverterString.lift(value)

    @staticmethod
    def lower(value):
        return FfiConverterString.lower(value)
class FfiConverterUInt8(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def write(value, buf):
        buf.writeU8(value)
class FfiConverterUInt16(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU16()

    @staticmethod
    def write(value, buf):
        buf.writeU16(value)
class FfiConverterInt32(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readI32()

    @staticmethod
    def write(value, buf):
        buf.writeI32(value)
class FfiConverterUInt64(FfiConverterPrimitive):
    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def write(value, buf):
        buf.writeU64(value)
class FfiConverterString:
    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()
# The Duration type.
# There is a loss of precision when converting from Rust durations,
# which are accurate to the nanosecond,
# to Python durations, which are only accurate to the microsecond.
class FfiConverterDuration(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.readU64()
        microseconds = buf.readU32() / 1.0e3
        return datetime.timedelta(seconds=seconds, microseconds=microseconds)

    @staticmethod
    def write(value, buf):
        seconds = value.seconds + value.days * 24 * 3600
        nanoseconds = value.microseconds * 1000
        if seconds < 0:
            raise ValueError("Invalid duration, must be non-negative")
        buf.writeI64(seconds)
        buf.writeU32(nanoseconds)
# Helper code for HttpClient class is found in ObjectTemplate.py
# Helper code for WsClient class is found in ObjectTemplate.py
# Helper code for ApiResponse record is found in RecordTemplate.py
# Helper code for AppInfo record is found in RecordTemplate.py
# Helper code for DeviceInfo record is found in RecordTemplate.py
# Helper code for HttpClientConfig record is found in RecordTemplate.py
# Helper code for PlatformInfo record is found in RecordTemplate.py
# Helper code for RequestOption record is found in RecordTemplate.py
# Helper code for AppId enum is found in EnumTemplate.py
# Helper code for Env enum is found in EnumTemplate.py
# Helper code for ReadyState enum is found in EnumTemplate.py
# Helper code for AnyhowError error is found in ErrorTemplate.py
# Helper code for ApiError error is found in ErrorTemplate.py


class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class FfiConverterOptionalDuration(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterDuration.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterDuration.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class FfiConverterOptionalTypeDeviceInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeDeviceInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeDeviceInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class FfiConverterOptionalTypePlatformInfo(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypePlatformInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypePlatformInfo.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class FfiConverterOptionalTypeRequestOption(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeRequestOption.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeRequestOption.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class FfiConverterOptionalTypeEnv(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeEnv.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeEnv.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class FfiConverterOptionalTypeJson(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeJson.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeJson.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class FfiConverterSequenceUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt8.read(buf) for i in range(count)
        ]


class FfiConverterMapStringString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.writeI32(len(items))
        for (key, value) in items.items():
            FfiConverterString.write(key, buf)
            FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = FfiConverterString.read(buf)
            val = FfiConverterString.read(buf)
            d[key] = val
        return d
# Helper code for Bytes is found in CustomType.py
# Helper code for HeaderMap is found in CustomType.py
# Helper code for Json is found in CustomType.py
# Helper code for Url is found in CustomType.py

__all__ = [
    "InternalError",
    "Env",
    "AppId",
    "ReadyState",
    "AppInfo",
    "DeviceInfo",
    "PlatformInfo",
    "RequestOption",
    "ApiResponse",
    "HttpClientConfig",
    "init_engine",
    "HttpClient",
    "WsClient",
    "AnyhowError",
    "ApiError",
    "Binding",
    "Session",
    "WsCallback",
]

